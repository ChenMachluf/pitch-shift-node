{"version":3,"sources":["webpack:///webpack/bootstrap dabb927a8c80b1c667a9","webpack:///./examples/index.js","webpack:///./pitch-shift-node.js","webpack:///./~/pitch-shift/pitchshift.js","webpack:///./~/pitch-shift/~/frame-hop/hop.js","webpack:///./~/pitch-shift/~/overlap-add/overlap.js","webpack:///./~/pitch-shift/~/detect-pitch/pitch.js","webpack:///./~/pitch-shift/~/detect-pitch/~/bit-twiddle/twiddle.js","webpack:///./~/pitch-shift/~/typedarray-pool/pool.js","webpack:///./~/pitch-shift/~/typedarray-pool/~/bit-twiddle/twiddle.js","webpack:///./~/pitch-shift/~/typedarray-pool/~/dup/dup.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray/index.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray/lib/tools.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray/lib/viewn.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-ops/index.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/index.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/lib/parser.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/~/falafel/index.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/~/falafel/~/esprima/esprima.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/lib/shim.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/lib/generate.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/fft.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/index.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/lib/parser.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/~/falafel/index.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/~/falafel/~/esprima/esprima.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/lib/shim.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/lib/generate.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/lib/fft-matrix.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/typedarray-pool/pool.js","webpack:///./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/typedarray-pool/~/dup/dup.js","webpack:///./~/typedarray-pool/pool.js","webpack:///(webpack)/~/node-libs-browser/~/buffer/index.js","webpack:///(webpack)/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js","webpack:///(webpack)/~/node-libs-browser/~/buffer/~/ieee754/index.js","webpack:///(webpack)/~/node-libs-browser/~/buffer/~/isarray/index.js","webpack:///./~/typedarray-pool/~/bit-twiddle/twiddle.js","webpack:///./~/typedarray-pool/~/dup/dup.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,EAAC;;;AAGD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA2B,0BAA0B;AACrD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,4BAA2B,qBAAqB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uDAAsD,0BAA0B;;AAEhF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;ACtPA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;;;;ACnDA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB;AACA,iBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,M;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC3IA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,YAAY;AAChC;AACA;AACA,UAAS,KAAK;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,gBAAe,MAAM;AACrB;AACA;AACA;AACA,mBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACvGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B,6BAA4B,cAAc;AAC1C,6BAA4B,cAAc;AAC1C,6BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAc,OAAO;AACrB;AACA,mBAAkB,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AC7MA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3RA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B,6BAA4B,cAAc;AAC1C,6BAA4B,cAAc;AAC1C,6BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAc,OAAO;AACrB;AACA,mBAAkB,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AC7MA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB;AACA;AACA,IAAG;AACH,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnDA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,eAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,iBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,MAAM;AACnC;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA,eAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,KAAK;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA,IAAG;AACH,mBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChLA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA;;;;;;;;;ACrBA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,qBAAqB;AACnC;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,8BAA6B,MAAM;AACnC;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3OA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,eAAc,oBAAoB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,8BAA6B;AAC7B;AACA;AACA;AACA,qBAAoB;;AAEpB,+BAA8B;AAC9B;AACA;AACA;AACA,qBAAoB;AACpB;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,eAAc,uBAAuB;AACrC;AACA,yBAAwB;AACxB;AACA;AACA;AACA,qBAAoB;;AAEpB,6BAA4B;AAC5B;AACA;AACA;AACA,qBAAoB;;AAEpB,8BAA6B;AAC7B;AACA;AACA;AACA,qBAAoB;;AAEpB,+BAA8B;AAC9B;AACA;AACA;AACA,qBAAoB;;AAEpB,8BAA6B;AAC7B;AACA;AACA;AACA,qBAAoB;;AAEpB,+BAA8B;AAC9B;AACA;AACA;AACA,qBAAoB;;AAEpB,gCAA+B;AAC/B;AACA;AACA;AACA,qBAAoB;;AAEpB,iCAAgC;AAChC;AACA;AACA;AACA,qBAAoB;;AAEpB;AACA,EAAC;;AAED,sBAAqB;AACrB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,sBAAqB;AACrB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,sBAAqB;AACrB;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,uBAAsB;AACtB;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,+BAA8B;AAC9B;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;;AAIJ,wBAAuB;AACvB;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,0BAAyB;AACzB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,wBAAuB;AACvB;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,sBAAqB;AACrB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,sBAAqB;AACrB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,yBAAwB;AACxB;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,yBAAwB;AACxB;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,yBAAwB;AACxB;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;;;AAGJ,yBAAwB;AACxB;AACA;AACA,KAAI;;AAEJ,0BAAyB;AACzB;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,kCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpaA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACrFA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,sBAAsB;AACpC;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,8BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB;AACxB,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AChJA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iCAAgC,gCAAgC;AAChE,gCAA+B;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;;;;;;;;AChGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,mCAAkC;AAClC;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAsB,eAAe,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB,kCAAiC;AACjC;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,iBAAiB;AAC/C;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;;AAEA;AACA,kDAAiD;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA2D;;AAE3D,kBAAiB;;AAEjB,yBAAwB;AACxB;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C,sBAAqB;AACrB,8CAA6C;AAC7C;AACA,kBAAiB;AACjB;AACA,8CAA6C;AAC7C,sBAAqB;AACrB,8CAA6C;AAC7C;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;;AAEA,0BAAyB;AACzB;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAiB;;AAEjB;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,qBAAoB;AACpB;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;AACA;;AAEA;;AAEA,0BAAyB;AACzB;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qDAAoD;AACpD,iCAAgC;AAChC;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,kDAAiD;AACjD,iCAAgC;AAChC;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB;AACA,0BAAyB;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kCAAiC;AACjC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAiB;;AAEjB;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB;AACnB;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL,EAAC;AACD;;;;;;;;ACt0HA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,oBAAoB;;AAE9C;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA,WAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,WAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA;AACA,eAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACrGA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,aAAa;AACvB,6BAA4B;AAC5B;AACA;AACA,WAAU,SAAS;AACnB,aAAY,aAAa;AACzB;AACA;AACA;AACA,4DAA2D;AAC3D,QAAO;AACP,oGAAmG;AACnG;AACA;AACA;AACA;AACA,qBAAoB,MAAM;AAC1B;AACA,4CAA2C,YAAY,EAAE;AACzD;AACA;AACA;AACA;AACA,WAAU,aAAa;AACvB;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;;AAEA,mBAAkB,aAAa;AAC/B,qCAAoC;AACpC;AACA;AACA;AACA,mBAAkB,wBAAwB;AAC1C;AACA,mBAAkB;AAClB;;AAEA,2CAA0C;AAC1C;AACA,iBAAgB,OAAO;;AAEvB;AACA;AACA,0BAAyB,MAAM,OAAO,SAAS;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAsB,KAAK,MAAM;AACjC,iBAAgB,aAAa;AAC7B;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,mBAAkB;;AAElB;AACA,0BAAyB;AACzB;AACA,iBAAgB,aAAa;AAC7B;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,mBAAkB;AAClB,iBAAgB;;AAEhB;AACA,0BAAyB;AACzB;AACA,iBAAgB;AAChB;AACA,aAAY,aAAa;AACzB;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA;AACA,aAAY,aAAa;AACzB;AACA;AACA,aAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA,aAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7NA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC7EA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACrFA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,sBAAsB;AACpC;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,8BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB;AACxB,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AChJA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iCAAgC,gCAAgC;AAChE,gCAA+B;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;;;;;;;;AChGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,mCAAkC;AAClC;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAsB,eAAe,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB,kCAAiC;AACjC;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,iBAAiB;AAC/C;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;;AAEA;AACA,kDAAiD;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA2D;;AAE3D,kBAAiB;;AAEjB,yBAAwB;AACxB;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C,sBAAqB;AACrB,8CAA6C;AAC7C;AACA,kBAAiB;AACjB;AACA,8CAA6C;AAC7C,sBAAqB;AACrB,8CAA6C;AAC7C;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;;AAEA,0BAAyB;AACzB;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAiB;;AAEjB;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,qBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,qBAAoB;AACpB;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;AACA;;AAEA;;AAEA,0BAAyB;AACzB;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qDAAoD;AACpD,iCAAgC;AAChC;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,kDAAiD;AACjD,iCAAgC;AAChC;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB;AACA,0BAAyB;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kCAAiC;AACjC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAiB;;AAEjB;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB;AACnB;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL,EAAC;AACD;;;;;;;;ACt0HA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,oBAAoB;;AAE9C;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA,eAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA,WAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,WAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA;AACA,eAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACrGA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,aAAa;AACvB,6BAA4B;AAC5B;AACA;AACA,WAAU,SAAS;AACnB,aAAY,aAAa;AACzB;AACA;AACA;AACA,4DAA2D;AAC3D,QAAO;AACP,oGAAmG;AACnG;AACA;AACA;AACA;AACA,qBAAoB,MAAM;AAC1B;AACA,4CAA2C,YAAY,EAAE;AACzD;AACA;AACA;AACA;AACA,WAAU,aAAa;AACvB;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;;AAEA,mBAAkB,aAAa;AAC/B,qCAAoC;AACpC;AACA;AACA;AACA,mBAAkB,wBAAwB;AAC1C;AACA,mBAAkB;AAClB;;AAEA,2CAA0C;AAC1C;AACA,iBAAgB,OAAO;;AAEvB;AACA;AACA,0BAAyB,MAAM,OAAO,SAAS;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAsB,KAAK,MAAM;AACjC,iBAAgB,aAAa;AAC7B;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,mBAAkB;;AAElB;AACA,0BAAyB;AACzB;AACA,iBAAgB,aAAa;AAC7B;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,mBAAkB;AAClB,iBAAgB;;AAEhB;AACA,0BAAyB;AACzB;AACA,iBAAgB;AAChB;AACA,aAAY,aAAa;AACzB;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA;AACA,aAAY,aAAa;AACzB;AACA;AACA,aAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA,aAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7NA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAY,WAAW,S;AACvB;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,YAAY;AAC1B;AACA;AACA,eAAc,YAAY;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA,aAAY,WAAW;;AAEvB;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;;AAEA;AACA;;AAEA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC3NA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvLA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB;AACA;AACA,IAAG;AACH,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnDA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxNA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA,iBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,6BAA6B;AAChD;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA,IAAG;AACH;AACA,gBAAe,SAAS;AACxB;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;;;;;;;;AC9gDA;AACA;;AAEA;;AAEA,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAiD,YAAY;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAC,6BAAqD;;;;;;;;AC9HtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,SAAQ,WAAW;;AAEnB;AACA;AACA,SAAQ,UAAU;;AAElB;AACA;;;;;;;;ACtFA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;;;;;;;;ACPA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B,6BAA4B,cAAc;AAC1C,6BAA4B,cAAc;AAC1C,6BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAc,OAAO;AACrB;AACA,mBAAkB,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AC7MA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB;AACA;AACA,IAAG;AACH,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"examples/example.build.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap dabb927a8c80b1c667a9\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar pitchShiftNode = require('../pitch-shift-node');\r\n\r\nwindow.requestAnimFrame = (function() {\r\n\r\n    return (window.requestAnimationFrame ||\r\n        window.webkitRequestAnimationFrame ||\r\n        window.mozRequestAnimationFrame ||\r\n        function(callback) {\r\n            window.setTimeout(callback, 1000 / 60);\r\n        });\r\n})();\r\n\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", Start, true);\r\n\r\nfunction Start() {\r\n\r\n    var audioContext = new AudioContext(),\r\n        audioSource,\r\n        pitchNode,\r\n        spectrumAudioAnalyser,\r\n        sonogramAudioAnalyser,\r\n        canvas,\r\n        canvasContext,\r\n        barGradient,\r\n        waveGradient;\r\n\r\n    var audioVisualisationNames = ['Spectrum', 'Wave', 'Sonogram'],\r\n        audioVisualisationIndex = 0,\r\n        pitchRatio = 1.0,\r\n        playbackRate = 1.0,\r\n        spectrumFFTSize = 256,\r\n        spectrumSmoothing = 0.8,\r\n        sonogramFFTSize = 1024,\r\n        sonogramSmoothing = 0;\r\n\r\n    init();\r\n\r\n    function init() {\r\n        spectrumAudioAnalyser = audioContext.createAnalyser();\r\n        spectrumAudioAnalyser.fftSize = spectrumFFTSize;\r\n        spectrumAudioAnalyser.smoothingTimeConstant = spectrumSmoothing;\r\n\r\n        sonogramAudioAnalyser = audioContext.createAnalyser();\r\n        sonogramAudioAnalyser.fftSize = sonogramFFTSize;\r\n        sonogramAudioAnalyser.smoothingTimeConstant = sonogramSmoothing;\r\n\r\n        initPitchNode();\r\n        loadAudio();\r\n        initSliders();\r\n        initCanvas();\r\n        window.requestAnimFrame(renderCanvas);\r\n    }\r\n\r\n    function loadAudio() {\r\n        var request = new XMLHttpRequest();\r\n        request.open(\"GET\", 'audio/gettysburg_address_64kb.mp3', true);\r\n        request.responseType = \"arraybuffer\";\r\n\r\n        var loader = this;\r\n        request.onload = function() {\r\n\r\n            // Asynchronously decode the audio file data in request.response\r\n            audioContext.decodeAudioData(\r\n\r\n                request.response,\r\n\r\n                function(buffer) {\r\n                    if (!buffer) {\r\n                        alert('error decoding file data');\r\n                        return;\r\n                    }\r\n\r\n                    audioSource = audioContext.createBufferSource();\r\n                    audioSource.buffer = buffer;\r\n                    audioSource.loop = true;\r\n                    audioSource.playbackRate.value = playbackRate;\r\n                    audioSource.start(0);\r\n                    if (pitchNode) {\r\n                        audioSource.connect(pitchNode);\r\n                    }\r\n                },\r\n\r\n                function(error) {\r\n                    console.error('decodeAudioData error', error);\r\n                }\r\n            );\r\n        }\r\n\r\n        request.onerror = function() {\r\n            alert('BufferLoader: XHR error');\r\n        }\r\n\r\n        request.send();\r\n    }\r\n\r\n    function initPitchNode() {\r\n        if (pitchNode) {\r\n            pitchNode.disconnect();\r\n            if (audioSource) {\r\n                audioSource.disconnect();\r\n            }\r\n        }\r\n\r\n        pitchNode = new pitchShiftNode(audioContext, pitchRatio);\r\n\r\n        if (audioSource) {\r\n            audioSource.connect(pitchNode);\r\n        }\r\n\r\n        pitchNode.connect(spectrumAudioAnalyser);\r\n        pitchNode.connect(sonogramAudioAnalyser);\r\n        pitchNode.connect(audioContext.destination);\r\n    }\r\n\r\n    function initSliders() {\r\n        $(\"#pitchRatioSlider\").slider({\r\n            orientation: \"horizontal\",\r\n            min: 0.5,\r\n            max: 2,\r\n            step: 0.001,\r\n            range: 'min',\r\n            value: pitchRatio,\r\n            slide: function(event, ui) {\r\n                pitchRatio = ui.value;\r\n                pitchNode.shiftOffset = pitchRatio;\r\n                $(\"#pitchRatioDisplay\").text(pitchRatio);\r\n            }\r\n        });\r\n\r\n        $(\"#audioVisualisationSlider\").slider({\r\n            orientation: \"horizontal\",\r\n            min: 0,\r\n            max: audioVisualisationNames.length - 1,\r\n            step: 1,\r\n            value: audioVisualisationIndex,\r\n            slide: function(event, ui) {\r\n                audioVisualisationIndex = ui.value;\r\n                $(\"#audioVisualisationDisplay\").text(audioVisualisationNames[audioVisualisationIndex]);\r\n            }\r\n        });\r\n\r\n        $(\"#playbackRateSlider\").slider({\r\n            orientation: \"horizontal\",\r\n            min: 0.5,\r\n            max: 2,\r\n            step: 0.001,\r\n            range: 'min',\r\n            value: playbackRate,\r\n            slide: function(event, ui) {\r\n                playbackRate = ui.value;\r\n                if (audioSource) {\r\n                    audioSource.playbackRate.value = playbackRate;\r\n                }\r\n                $(\"#playbackRateDisplay\").text(playbackRate);\r\n            }\r\n        });\r\n\r\n        $(\"#pitchRatioDisplay\").text(pitchRatio);\r\n        $(\"#audioVisualisationDisplay\").text(audioVisualisationNames[audioVisualisationIndex]);\r\n        $(\"#playbackRateDisplay\").text(playbackRate);\r\n    }\r\n\r\n    function initCanvas() {\r\n\r\n        canvas = document.querySelector('canvas');\r\n        canvasContext = canvas.getContext('2d');\r\n\r\n        barGradient = canvasContext.createLinearGradient(0, 0, 1, canvas.height - 1);\r\n        barGradient.addColorStop(0, '#550000');\r\n        barGradient.addColorStop(0.995, '#AA5555');\r\n        barGradient.addColorStop(1, '#555555');\r\n\r\n        waveGradient = canvasContext.createLinearGradient(canvas.width - 2, 0, canvas.width - 1, canvas.height - 1);\r\n        waveGradient.addColorStop(0, '#FFFFFF');\r\n        waveGradient.addColorStop(0.75, '#550000');\r\n        waveGradient.addColorStop(0.75, '#555555');\r\n        waveGradient.addColorStop(0.76, '#AA5555');\r\n        waveGradient.addColorStop(1, '#FFFFFF');\r\n    }\r\n\r\n    function renderCanvas() {\r\n        switch (audioVisualisationIndex) {\r\n\r\n            case 0:\r\n\r\n                var frequencyData = new Uint8Array(spectrumAudioAnalyser.frequencyBinCount);\r\n                spectrumAudioAnalyser.getByteFrequencyData(frequencyData);\r\n\r\n                canvasContext.clearRect(0, 0, canvas.width, canvas.height);\r\n                canvasContext.fillStyle = barGradient;\r\n\r\n                var barWidth = canvas.width / frequencyData.length;\r\n                for (i = 0; i < frequencyData.length; i++) {\r\n                    var magnitude = frequencyData[i];\r\n                    canvasContext.fillRect(barWidth * i, canvas.height, barWidth - 1, -magnitude - 1);\r\n                }\r\n\r\n                break;\r\n\r\n            case 1:\r\n\r\n                var timeData = new Uint8Array(spectrumAudioAnalyser.frequencyBinCount);\r\n                spectrumAudioAnalyser.getByteTimeDomainData(timeData);\r\n                var amplitude = 0.0;\r\n                for (i = 0; i < timeData.length; i++) {\r\n                    amplitude += timeData[i];\r\n                }\r\n                amplitude = Math.abs(amplitude / timeData.length - 128) * 5 + 1;\r\n\r\n                var previousImage = canvasContext.getImageData(1, 0, canvas.width - 1, canvas.height);\r\n                canvasContext.putImageData(previousImage, 0, 0);\r\n\r\n                var axisY = canvas.height * 3 / 4;\r\n                canvasContext.fillStyle = '#FFFFFF';\r\n                canvasContext.fillRect(canvas.width - 1, 0, 1, canvas.height);\r\n                canvasContext.fillStyle = waveGradient;\r\n                canvasContext.fillRect(canvas.width - 1, axisY, 1, -amplitude);\r\n                canvasContext.fillRect(canvas.width - 1, axisY, 1, amplitude / 2);\r\n\r\n                break;\r\n\r\n            case 2:\r\n\r\n                frequencyData = new Uint8Array(sonogramAudioAnalyser.frequencyBinCount);\r\n                sonogramAudioAnalyser.getByteFrequencyData(frequencyData);\r\n\r\n                previousImage = canvasContext.getImageData(1, 0, canvas.width - 1, canvas.height);\r\n                canvasContext.putImageData(previousImage, 0, 0);\r\n\r\n                var bandHeight = canvas.height / frequencyData.length;\r\n                for (var i = 0, y = canvas.height - 1; i < frequencyData.length; i++, y -= bandHeight) {\r\n\r\n                    var color = frequencyData[i] << 16;\r\n                    canvasContext.fillStyle = '#' + color.toString(16);\r\n                    canvasContext.fillRect(canvas.width - 1, y, 1, -bandHeight);\r\n                }\r\n\r\n                break;\r\n        }\r\n\r\n        window.requestAnimFrame(renderCanvas);\r\n    }\r\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./examples/index.js\n ** module id = 0\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar pitchShift = require('pitch-shift');\r\nvar pool = require('typedarray-pool');\r\n\r\nfunction PitchShiftNode(context, shiftOffset, options) {\r\n    var queue = [];\r\n\r\n    options = options || {};\r\n    options.frameSize = options.frameSize || 512;\r\n    options.hopSize = options.hopSize || options.frameSize / 4;\r\n\r\n    var shifter = pitchShift(onData, onTune, options);\r\n\r\n    var scriptNode = context.createScriptProcessor(options.frameSize, 1, 1);\r\n    scriptNode.onaudioprocess = function(e) {\r\n        shift(e.inputBuffer.getChannelData(0));\r\n        var out = e.outputBuffer.getChannelData(0);\r\n        var q = queue[0];\r\n        queue.shift();\r\n        out.set(q);\r\n        pool.freeFloat32(q);\r\n    };\r\n    scriptNode.shiftOffset = shiftOffset;\r\n\r\n    //Enque some garbage to buffer stuff\r\n    shift(new Float32Array(options.frameSize));\r\n    shift(new Float32Array(options.frameSize));\r\n    shift(new Float32Array(options.frameSize));\r\n    shift(new Float32Array(options.frameSize));\r\n    shift(new Float32Array(options.frameSize));\r\n\r\n    return scriptNode;\r\n\r\n    function shift(frame) {\r\n        shifter(frame);\r\n    }\r\n\r\n    function onData(data) {\r\n        var buf = pool.mallocFloat32(data.length);\r\n        buf.set(data);\r\n        queue.push(buf);\r\n    }\r\n\r\n    function onTune(t, pitch) {\r\n        return scriptNode.shiftOffset;\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = PitchShiftNode;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./pitch-shift-node.js\n ** module id = 1\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar frameHop = require(\"frame-hop\")\nvar overlapAdd = require(\"overlap-add\")\nvar detectPitch = require(\"detect-pitch\")\nvar pool = require(\"typedarray-pool\")\n\nfunction createWindow(n) {\n  var result = new Float32Array(n)\n  for(var i=0; i<n; ++i) {\n    var t = i / (n-1)\n    result[i] = 0.5 * (1.0 - Math.cos(2.0*Math.PI * t))\n  }\n  return result\n}\n\nfunction normalizeWindow(w, hop_size) {\n  var n = w.length\n  var nh = (n / hop_size)|0\n  var scale = pool.mallocFloat32(n)\n  for(var i=0; i<n; ++i) {\n    var s = 0.0\n    for(var j=0; j<nh; ++j) {\n      s += w[(i + j*hop_size)%n]\n    }\n    scale[i] = s\n  }\n  for(var i=0; i<n; ++i) {\n    w[i] /= scale[i]\n  }\n  pool.freeFloat32(scale)\n}\n\n//Applies window to signal\nfunction applyWindow(X, W, frame) {\n  var i, n = frame.length\n  for(i=0; i<n; ++i) {\n    X[i] = W[i] * frame[i]\n  }\n}\n\n//Performs the actual pitch scaling\nfunction scalePitch(out, x, nx, period, scale, shift, w) {\n  var no = out.length\n  for(var i=0; i<no; ++i) {\n    var t  = i * scale + shift\n    var ti = Math.floor(t)|0\n    var tf = t - ti\n    var x1 = x[ti%nx]\n    var x2 = x[(ti+1)%nx]\n    var v = (1.0 - tf) * x1 + tf * x2\n    out[i] = w[i] * v\n  }\n}\n\n//Match start/end points of signal to avoid popping artefacts\nfunction findMatch(x, start, step) {\n  var a = x[0], b = x[step], c = x[2*step]\n  var n = x.length\n  var best_d = 8\n  var best_i = start\n  for(var i=start; i<n-2*step; ++i) {\n    var s = x[i]-a, t = x[i+step]-b, u=x[i+2*step]-c\n    var d = s*s + t*t + u*u\n    if( d < best_d ) {\n      best_d = d\n      best_i = i\n    }\n  }\n  return best_i\n}\n\nfunction pitchShift(onData, onTune, options) {\n  options = options || {}\n  \n  var frame_size  = options.frameSize || 2048\n  var hop_size    = options.hopSize || (frame_size>>>2)\n  var sample_rate = options.sampleRate || 44100\n  var data_size   = options.maxDataSize || undefined\n  var a_window    = options.analysisWindow || createWindow(frame_size)\n  var s_window    = options.synthesisWindow || createWindow(frame_size)\n  var threshold   = options.freqThreshold || 0.9\n  var start_bin   = options.minPeriod || Math.min(hop_size, Math.max(16, Math.round(sample_rate / 400)))|0\n  \n  var detect_params = {\n    threshold: threshold,\n    start_bin: start_bin\n  }\n  \n  var t           = 0\n  var cur         = new Float32Array(frame_size)\n  \n  if(frame_size % hop_size !== 0) {\n    throw new Error(\"Hop size must divide frame size\")\n  }\n  \n  //Normalize synthesis window\n  normalizeWindow(s_window, hop_size)\n  \n  var addFrame = overlapAdd(frame_size, hop_size, onData)\n  var delay = 0\n  \n  function doPitchShift(frame) {\n\n    //Apply window\n    applyWindow(cur, a_window, frame)\n    \n    //Compute pitch, period and sample rate\n    var period = detectPitch(cur, detect_params)\n    var pitch = 0.0\n    if(period > 0) {\n      pitch = sample_rate / period\n    }\n    var scale_f = onTune(t / sample_rate, pitch)\n    \n    //Calculate frame size\n    var fsize = frame_size>>1\n    if(period > 0) {\n      fsize = (Math.max(1, Math.floor(0.5*frame_size/period)) * period)|0\n    }    \n    fsize = findMatch(frame, fsize|0, Math.max(1, period/20)|0)\n    \n    //Apply scaling\n    delay = ((delay % fsize) + fsize) % fsize\n    scalePitch(cur, frame, fsize, period|0, scale_f, delay, s_window)\n    \n    //Update counters\n    delay += hop_size * (scale_f - 1.0)\n    t += hop_size\n    \n    //Add frame\n    addFrame(cur)\n  }\n  \n  return frameHop(frame_size, hop_size, doPitchShift, data_size)\n}\nmodule.exports = pitchShift\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/pitchshift.js\n ** module id = 2\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\n// Slices a stream of frames into a stream of overlapping windows\n// The size of each frame is the same as the size o\nfunction createHopStream(frame_size, hop_size, onFrame, max_data_size) {\n  if(hop_size > frame_size) {\n    throw new Error(\"Hop size must be smaller than frame size\")\n  }\n  max_data_size     = max_data_size || frame_size\n  var buffer        = new Float32Array(frame_size + max_data_size)\n  var ptr           = 0\n  var frame_slices  = []\n  for(var j=0; j+frame_size<=buffer.length; j+=hop_size) {\n    frame_slices.push(buffer.subarray(j, j+frame_size))\n  }\n  return function processHopData(data) {\n    var i, j, k\n    buffer.set(data, ptr)\n    ptr += data.length\n    for(i=0, j=0; j+frame_size<=ptr; ++i, j+=hop_size) {\n      onFrame(frame_slices[i])\n    }\n    for(k=0; j<ptr; ) {\n      buffer.set(frame_slices[i], k)\n      var nhops = Math.ceil((k+frame_size) / hop_size)|0\n      var nptr  = nhops * hop_size\n      if(nptr !== k+frame_size) {\n        nhops -= 1\n        nptr -= hop_size\n      }\n      i += nhops\n      j += (nptr - k)\n      k  = nptr\n    }\n    ptr += k - j\n  }\n}\n\nmodule.exports = createHopStream\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/frame-hop/hop.js\n ** module id = 3\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nfunction overlapAdd(frame_size, hop_size, onFrame) {\n  if(hop_size > frame_size) {\n    throw new Error(\"Hop size must be smaller than frame size\")\n  }\n  var buffer = new Float32Array(2 * frame_size)\n  var first_slice = buffer.subarray(0, frame_size)\n  var second_slice = buffer.subarray(frame_size)\n  var sptr = 0, eptr = 0\n  return function processOverlapAdd(data) {\n    var n = frame_size\n    var i, j, k\n    var B = buffer\n    \n    //Add data to frame\n    k = eptr\n    for(i=0, j=sptr; j<k && i<n; ++i, ++j) {\n      B[j] += data[i]\n    }\n    for(; i<n; ++i, ++j) {\n      B[j] = data[i]\n    }\n    sptr += hop_size\n    eptr = j\n    \n    //Emit frame if necessary\n    if(sptr >= frame_size) {\n      onFrame(first_slice)\n      first_slice.set(second_slice)\n      sptr -= frame_size\n      eptr -= frame_size\n    }\n  }\n}\n\nmodule.exports = overlapAdd\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/overlap-add/overlap.js\n ** module id = 4\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar bits = require(\"bit-twiddle\")\nvar pool = require(\"typedarray-pool\")\nvar ndarray = require(\"ndarray\")\nvar ops = require(\"ndarray-ops\")\nvar fft = require(\"ndarray-fft\")\n\nfunction zero(arr, lo, hi) {\n  for(var i=lo; i<hi; ++i) {\n    arr[i] = 0.0\n  }\n}\n\nfunction square(x, y) {\n  var n = x.length, n2 = Math.ceil(0.5*n)|0\n  x[0] = y[0] = 0.0\n  for(var i=1; i<n2; ++i) {\n    var a = x[i], b = y[i]\n    x[n-i] = x[i] = a*a + b*b\n    y[n-i] = y[i] = 0.0\n  }\n}\n\nfunction findPeriod(x, lo, hi, scale_f) {\n  //1st pass compute best val\n  var loc_m = 0.0\n  for(var i=lo; i<hi; ++i) {\n    loc_m = Math.max(loc_m, x[i])\n  }\n  //2nd pass compute max\n  var threshold = loc_m * scale_f\n  for(var i=lo; i<hi; ++i) {\n    if(x[i] > threshold) {\n      var best = x[i]\n      var r = i\n      for(var j=i; j < hi && x[j] > threshold; ++j) {\n        if(x[j] > best) {\n          best = x[j]\n          r = j\n        }\n      }\n      var y0 = x[r-1], y1 = x[r], y2 = x[r+1]\n      var denom = y2 - y1 + y0\n      if(Math.abs(denom) < 1e-6) {\n        return r\n      }\n      var numer = y0 - y2\n      return r + 0.5 * numer / denom\n    }\n  }\n  return 0\n}\n\nfunction detectPitch(signal, options) {\n  options = options || {}\n  var xs\n  if(signal.shape) {\n    xs = signal.shape[0]\n  } else {\n    xs = signal.length\n  }\n  \n  var i, j, k\n  var n = bits.nextPow2(2*xs)\n  var re_arr = pool.mallocFloat(n)\n  var im_arr = pool.mallocFloat(n)\n  var X = ndarray.ctor(re_arr, [n], [1], 0)\n  var Y = ndarray.ctor(im_arr, [n], [1], 0)\n  \n  //Initialize array depending on if it is a typed array\n  if(signal.shape) {\n    X.shape[0] = xs\n    ops.assign(X, signal)\n    X.shape[0] = n\n  } else {\n    re_arr.set(signal)\n  }\n  zero(re_arr, xs, n)\n  zero(im_arr, 0, n)\n  \n  //Autocorrelate\n  fft(1, X, Y)\n  square(re_arr, im_arr)\n  fft(-1, X, Y)\n  \n  //Detect pitch\n  var threshold = options.threshold || 0.9\n  var period = findPeriod(\n          re_arr,\n          options.start_bin || 16,\n          xs>>>1,\n          threshold)\n  \n  //Free temporary arrays\n  pool.freeFloat(re_arr)\n  pool.freeFloat(im_arr)\n  \n  return period\n}\nmodule.exports = detectPitch\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/pitch.js\n ** module id = 5\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/bit-twiddle/twiddle.js\n ** module id = 6\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar bits = require(\"bit-twiddle\")\nvar dup = require(\"dup\")\nif(!global.__TYPEDARRAY_POOL) {\n  global.__TYPEDARRAY_POOL = {\n      UINT8   : dup([32, 0])\n    , UINT16  : dup([32, 0])\n    , UINT32  : dup([32, 0])\n    , INT8    : dup([32, 0])\n    , INT16   : dup([32, 0])\n    , INT32   : dup([32, 0])\n    , FLOAT   : dup([32, 0])\n    , DOUBLE  : dup([32, 0])\n    , DATA    : dup([32, 0])\n  }\n}\nvar POOL = global.__TYPEDARRAY_POOL\nvar UINT8   = POOL.UINT8\n  , UINT16  = POOL.UINT16\n  , UINT32  = POOL.UINT32\n  , INT8    = POOL.INT8\n  , INT16   = POOL.INT16\n  , INT32   = POOL.INT32\n  , FLOAT   = POOL.FLOAT\n  , DOUBLE  = POOL.DOUBLE\n  , DATA    = POOL.DATA\n\nexports.free = function free(array) {\n  if(array instanceof ArrayBuffer) {\n    var n = array.byteLength|0\n      , log_n = bits.log2(n)\n    DATA[log_n].push(array)\n  } else {\n    var n = array.length|0\n      , log_n = bits.log2(n)\n    if(array instanceof Uint8Array) {\n      UINT8[log_n].push(array)\n    } else if(array instanceof Uint16Array) {\n      UINT16[log_n].push(array)\n    } else if(array instanceof Uint32Array) {\n      UINT32[log_n].push(array)\n    } else if(array instanceof Int8Array) {\n      INT8[log_n].push(array)\n    } else if(array instanceof Int16Array) {\n      INT16[log_n].push(array)\n    } else if(array instanceof Int32Array) {\n      INT32[log_n].push(array)\n    } else if(array instanceof Float32Array) {\n      FLOAT[log_n].push(array)\n    } else if(array instanceof Float64Array) {\n      DOUBLE[log_n].push(array)\n    }\n  }\n}\n\nexports.freeUint8 = function freeUint8(array) {\n  UINT8[bits.log2(array.length)].push(array)\n}\n\nexports.freeUint16 = function freeUint16(array) {\n  UINT16[bits.log2(array.length)].push(array)\n}\n\nexports.freeUint32 = function freeUint32(array) {\n  UINT32[bits.log2(array.length)].push(array)\n}\n\nexports.freeInt8 = function freeInt8(array) {\n  INT8[bits.log2(array.length)].push(array)\n}\n\nexports.freeInt16 = function freeInt16(array) {\n  INT16[bits.log2(array.length)].push(array)\n}\n\nexports.freeInt32 = function freeInt32(array) {\n  INT32[bits.log2(array.length)].push(array)\n}\n\nexports.freeFloat32 = exports.freeFloat = function freeFloat(array) {\n  FLOAT[bits.log2(array.length)].push(array)\n}\n\nexports.freeFloat64 = exports.freeDouble = function freeDouble(array) {\n  DOUBLE[bits.log2(array.length)].push(array)\n}\n\nexports.freeArrayBuffer = function freeArrayBuffer(array) {\n  DATA[bits.log2(array.length)].push(array)\n}\n\nexports.malloc = function malloc(n, dtype) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  if(dtype === undefined) {\n    var d = DATA[log_n]\n    if(d.length > 0) {\n      var r = d[d.length-1]\n      d.pop()\n      return r\n    }\n    return new ArrayBuffer(n)\n  } else {\n    switch(dtype) {\n      case \"uint8\":\n        var u8 = UINT8[log_n]\n        if(u8.length > 0) {\n          return u8.pop()\n        }\n        return new Uint8Array(n)\n      break\n\n      case \"uint16\":\n        var u16 = UINT16[log_n]\n        if(u16.length > 0) {\n          return u16.pop()\n        }\n        return new Uint16Array(n)\n      break\n\n      case \"uint32\":\n        var u32 = UINT32[log_n]\n        if(u32.length > 0) {\n          return u32.pop()\n        }\n        return new Uint32Array(n)\n      break\n\n      case \"int8\":\n        var i8 = INT8[log_n]\n        if(i8.length > 0) {\n          return i8.pop()\n        }\n        return new Int8Array(n)\n      break\n\n      case \"int16\":\n        var i16 = INT16[log_n]\n        if(i16.length > 0) {\n          return i16.pop()\n        }\n        return new Int16Array(n)\n      break\n\n      case \"int32\":\n        var i32 = INT32[log_n]\n        if(i32.length > 0) {\n          return i32.pop()\n        }\n        return new Int32Array(n)\n      break\n\n      case \"float\":\n      case \"float32\":\n        var f = FLOAT[log_n]\n        if(f.length > 0) {\n          return f.pop()\n        }\n        return new Float32Array(n)\n      break\n\n      case \"double\":\n      case \"float64\":\n        var dd = DOUBLE[log_n]\n        if(dd.length > 0) {\n          return dd.pop()\n        }\n        return new Float64Array(n)\n      break\n\n      default:\n        return null\n    }\n  }\n  return null\n}\n\nexports.mallocUint8 = function mallocUint8(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = UINT8[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Uint8Array(n)\n}\n\nexports.mallocUint16 = function mallocUint16(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = UINT16[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Uint16Array(n)\n}\n\nexports.mallocUint32 = function mallocUint32(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = UINT32[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Uint32Array(n)\n}\n\nexports.mallocInt8 = function mallocInt8(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = INT8[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Int8Array(n)\n}\n\nexports.mallocInt16 = function mallocInt16(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = INT16[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Int16Array(n)\n}\n\nexports.mallocInt32 = function mallocInt32(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = INT32[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Int32Array(n)\n}\n\nexports.mallocFloat32 = exports.mallocFloat = function mallocFloat(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = FLOAT[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Float32Array(n)\n}\n\nexports.mallocFloat64 = exports.mallocDouble = function mallocDouble(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = DOUBLE[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Float64Array(n)\n}\n\nexports.mallocArrayBuffer = function mallocArrayBuffer(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = DATA[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new ArrayBuffer(n)\n}\n\nexports.clearCache = function clearCache() {\n  for(var i=0; i<32; ++i) {\n    UINT8[i].length = 0\n    UINT16[i].length = 0\n    UINT32[i].length = 0\n    INT8[i].length = 0\n    INT16[i].length = 0\n    INT32[i].length = 0\n    FLOAT[i].length = 0\n    DOUBLE[i].length = 0\n    DATA[i].length = 0\n  }\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/typedarray-pool/pool.js\n ** module id = 7\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/typedarray-pool/~/bit-twiddle/twiddle.js\n ** module id = 8\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nfunction dupe_array(count, value, i) {\n  var c = count[i]|0\n  if(c <= 0) {\n    return []\n  }\n  var result = new Array(c), j\n  if(i === count.length-1) {\n    for(j=0; j<c; ++j) {\n      result[j] = value\n    }\n  } else {\n    for(j=0; j<c; ++j) {\n      result[j] = dupe_array(count, value, i+1)\n    }\n  }\n  return result\n}\n\nfunction dupe_number(count, value) {\n  var result, i\n  result = new Array(count)\n  for(i=0; i<count; ++i) {\n    result[i] = value\n  }\n  return result\n}\n\nfunction dupe(count, value) {\n  if(typeof value === \"undefined\") {\n    value = 0\n  }\n  switch(typeof count) {\n    case \"number\":\n      if(count > 0) {\n        return dupe_number(count|0, value)\n      }\n    break\n    case \"object\":\n      if(typeof (count.length) === \"number\") {\n        return dupe_array(count, value, 0)\n      }\n    break\n  }\n  return []\n}\n\nmodule.exports = dupe\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/typedarray-pool/~/dup/dup.js\n ** module id = 9\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar tools = require(\"./lib/tools.js\")\nvar makeView = require(\"./lib/viewn.js\")\n\nfunction arrayDType(data) {\n  if(data instanceof Float64Array) {\n    return \"float64\";\n  } else if(data instanceof Float32Array) {\n    return \"float32\"\n  } else if(data instanceof Int32Array) {\n    return \"int32\"\n  } else if(data instanceof Uint32Array) {\n    return \"uint32\"\n  } else if(data instanceof Uint8Array) {\n    return \"uint8\"\n  } else if(data instanceof Uint16Array) {\n    return \"uint16\"\n  } else if(data instanceof Int16Array) {\n    return \"int16\"\n  } else if(data instanceof Int8Array) {\n    return \"int8\"\n  }\n  return null\n}\n\nfunction eor(shape, stride, offset) {\n  for(var i=0; i<shape.length; ++i) {\n    if(shape[i] === 0) {\n      return 0\n    }\n    offset += (shape[i]-1) * stride[i]\n  }\n  return offset\n}\n\n//Wraps a typed array as an ndarray\nfunction wrap(tarray, shape, stride, offset) {\n  if(!arrayDType(tarray)) {\n    throw new Error(\"Input is not a typed array\")\n  }\n  if(!shape) {\n    shape = [ tarray.length ]\n  } else {\n    var tsz = 1\n    for(var i=0; i<shape.length; ++i) {\n      tsz *= shape[i]\n    }\n    if(tsz > tarray.length) {\n      throw new Error(\"Array shape out of bounds\")\n    }\n  }\n  if(!stride) {\n    stride = new Array(shape.length)\n    var sz = 1\n    for(var i=shape.length-1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  } else if(stride.length !== shape.length) {\n    throw new Error(\"Bad stride length\")\n  }\n  if(!offset) {\n    offset = 0\n  }\n  if(tarray.length > 0) {\n    if(offset < 0 || offset >= tarray.length) {\n      throw new Error(\"Offset out of range\")\n    }\n    var e = eor(shape, stride, offset)\n    if(e < 0 || e >= tarray.length) {\n      throw new Error(\"Array shape out of bounds\")\n    }\n  } else {\n    offset = 0\n  }\n  return makeView(tarray, shape, stride, offset)\n}\n\nfunction dtype(view) {\n  return arrayDType(view.data)\n}\n\nfunction zeros(shape, dtype, order) {\n  if(!dtype) {\n    dtype = \"float64\"\n  }\n  //Default row-major order\n  if(!order) {\n    order = new Array(shape.length)\n    for(var i=shape.length-1, j=0; i>=0; --i, ++j) {\n      order[j] = i\n    }\n  }\n  var stride =  new Array(shape.length)\n  var size = 1\n  for(var i=0; i<shape.length; ++i) {\n    stride[order[i]] = size\n    size *= shape[order[i]]\n  }\n  var buf\n  switch(dtype) {\n    case \"int8\":\n      buf = new Int8Array(size)\n    break\n    case \"int16\":\n      buf = new Int16Array(size)\n    break\n    case \"int32\":\n      buf = new Int32Array(size)\n    break\n    case \"uint8\":\n      buf = new Uint8Array(size)\n    break\n    case \"uint16\":\n      buf = new Uint16Array(size)\n    break\n    case \"uint32\":\n      buf = new Uint32Array(size)\n    break\n    case \"float32\":\n      buf = new Float32Array(size)\n    break\n    case \"float64\":\n      buf = new Float64Array(size)\n    break\n    default:\n      throw new Error(\"Invalid data type\")\n    break\n  }\n  return makeView(buf, shape, stride, 0)\n}\n\nfunction order(view) {\n  return tools.order(view.stride)\n}\n\nfunction size(view) {\n  var shape = view.shape\n    , d = shape.length\n    , r = 1, i\n  if(d === 0) {\n    return 0\n  }\n  for(i=0; i<d; ++i) {\n    r *= shape[i]\n  }\n  return r\n}\n\nfunction pstride(shape, order) {\n  var i = 0, d = shape.length\n  var result = new Array(d), s = 1\n  if(order) {\n    for(i=0; i<d; ++i) {\n      result[order[i]] = s\n      s *= shape[order[i]]\n    }\n  } else {\n    for(var i=d-1; i>=0; --i) {\n      stride[i] = s\n      s *= shape[i]\n    }\n  }\n  return result\n}\n\nmodule.exports = wrap\nmodule.exports.zeros    = zeros\nmodule.exports.dtype    = dtype\nmodule.exports.order    = order\nmodule.exports.size     = size\nmodule.exports.stride   = pstride\nmodule.exports.ctor     = makeView\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray/index.js\n ** module id = 10\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\nfunction compare1st(a, b) {\n  return a[0] - b[0];\n}\n\nfunction order(stride) {\n  var terms = new Array(stride.length);\n  for(var i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i];\n  }\n  terms.sort(compare1st);\n  var result = new Array(terms.length);\n  for(var i=0; i<result.length; ++i) {\n    result[i] = terms[i][1];\n  }\n  return result;\n}\n\nexports.order = order;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray/lib/tools.js\n ** module id = 11\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar tools = require(\"./tools.js\")\n\nvar RECURSION_LIMIT = 32\n\nfunction ViewN(data, shape, stride, offset) {\n  this.data = data\n  this.shape = shape\n  this.stride = stride\n  this.offset = offset\n}\n\nViewN.prototype.get = function() {\n  var ptr = this.offset\n  for(var i=0; i<this.shape.length; ++i) {\n    ptr += arguments[i] * this.stride[i]\n  }\n  return this.data[ptr]\n}\nViewN.prototype.set = function() {\n  var ptr = this.offset\n  for(var i=0; i<this.shape.length; ++i) {\n    ptr += arguments[i] * this.stride[i]\n  }\n  var v = arguments[this.shape.length]\n  this.data[ptr] = v\n  return v\n}\nViewN.prototype.lo = function() {\n  var nshape = this.shape.slice(0)\n  var nstride = this.stride.slice(0)\n  var noffset = this.offset\n  for(var i=0; i<nshape.length; ++i) {\n    var x = arguments[i]\n    if(typeof x === \"number\") {\n      x |= 0\n      if(x < 0) {\n        x = nshape[i] + x\n      }\n      noffset += x * nstride[i]\n      nshape[i] -= x\n    }\n  }\n  return new this.constructor(this.data, nshape, nstride, noffset)\n}\nViewN.prototype.hi = function() {\n  var nshape = new Array(this.shape.length)\n  for(var i=0; i<nshape.length; ++i) {\n    var x = arguments[i]\n    if(typeof x === \"number\") {\n      x |= 0\n      if(x < 0) {\n        x = this.shape[i] + x\n      }\n      nshape[i] = x\n    } else {\n      nshape[i] = this.shape[i]\n    }\n  }\n  return new this.constructor(this.data, nshape, this.stride.slice(0), this.offset)\n}\nViewN.prototype.step = function() {\n  var nshape = this.shape.slice(0)\n  var nstride = this.stride.slice(0)\n  var noffset = this.offset\n  for(var i=0; i<nshape.length; ++i) {\n    var s = arguments[i]\n    nstride[i] *= s\n    if(s < 0) {\n      noffset += this.stride[i] * (this.shape[i] - 1)\n      nshape[i] = Math.ceil(-this.shape[i] / s)\n    } else if(s > 0) {\n      nshape[i] = Math.ceil(this.shape[i] / s)\n    }\n  }\n  return new this.constructor(this.data, nshape, nstride, noffset)\n}\nViewN.prototype.transpose = function() {\n  var nshape = this.shape.slice(0)\n  var nstride = this.stride.slice(0)\n  var noffset = this.offset\n  for(var i=0; i<nshape.length; ++i) {\n    var ord = arguments[i]\n    nshape[i] = this.shape[ord]\n    nstride[i] = this.stride[ord]\n  }\n  return new this.constructor(this.data, nshape, nstride, noffset)\n}\nViewN.prototype.pick = function() {\n  var nshape = []\n  var nstride = []\n  var noffset = this.offset\n  for(var i=0; i<this.shape.length; ++i) {\n    if(arguments[i] >= 0) {\n      noffset += this.stride[i] * arguments[i]\n    } else {\n      nshape.push(this.shape[i])\n      nstride.push(this.stride[i])\n    }\n  }\n  return CTOR(this.data, nshape, nstride, noffset)\n}\n\nViewN.prototype.toString = function() {\n  var buffer = []\n  var index = new Array(this.shape.length)\n  for(var i=0; i<index.length; ++i) {\n    index[i] = 0\n  }\n  var ptr = this.offset\n  while(true) {\n    for(var i=index.length-1; i>=0; --i) {\n      if(index[i] === 0) {\n        buffer.push(\"[\")\n      } else {\n        break\n      }\n    }\n    var i = this.shape.length-1\n    buffer.push(this.data[ptr])\n    while(i>=0) {\n      ptr += this.stride[i]\n      ++index[i]\n      if(index[i] >= this.shape[i]) {\n        buffer.push(\"]\")\n        if(i === 0) {\n          return buffer.join(\"\")\n        }\n        ptr -= this.stride[i] * this.shape[i]\n        index[i--] = 0\n      } else {\n        buffer.push(\",\")\n        break\n      }\n    }\n  }\n}\n\nfunction View0(data) {\n  this.data = data\n  this.shape = []\n  this.stride = []\n  this.offset = 0\n}\nView0.prototype.get =\nView0.prototype.set = function() {\n  return Number.NaN\n}\nView0.prototype.lo =\nView0.prototype.hi =\nView0.prototype.step =\nView0.prototype.transpose =\nView0.prototype.pick = function() {\n  return new View0(this.data)\n}\nView0.prototype.toString = function() {\n  return \"[]\"\n}\n\n\nfunction View1(data, shape, stride, offset) {\n  this.data = data\n  this.shape = shape\n  this.stride = stride\n  this.offset = offset\n}\nView1.prototype.get = function(i) {\n  return this.data[i * this.stride[0] + this.offset]\n}\nView1.prototype.set = function(i, v) {\n  this.data[i * this.stride[0] + this.offset] = v\n  return v\n}\nView1.prototype.lo = ViewN.prototype.lo\nView1.prototype.hi = ViewN.prototype.hi\nView1.prototype.step = ViewN.prototype.step\nView1.prototype.transpose = ViewN.prototype.transpose\nView1.prototype.pick = ViewN.prototype.pick\nView1.prototype.toString = ViewN.prototype.toString\n\n\nfunction View2(data, shape, stride, offset) {\n  this.data = data\n  this.shape = shape\n  this.stride = stride\n  this.offset = offset\n}\nView2.prototype.get = function(i, j) {\n  return this.data[this.offset + i * this.stride[0] + j * this.stride[1]]\n}\nView2.prototype.set = function(i, j, v) {\n  return this.data[this.offset + i * this.stride[0] + j * this.stride[1]] = v\n}\nView2.prototype.hi = ViewN.prototype.hi\nView2.prototype.lo = ViewN.prototype.lo\nView2.prototype.step = ViewN.prototype.step\nView2.prototype.transpose = ViewN.prototype.transpose\nView2.prototype.pick = ViewN.prototype.pick\nView2.prototype.toString = ViewN.prototype.toString\n\n\nfunction View3(data, shape, stride, offset) {\n  this.data = data\n  this.shape = shape\n  this.stride = stride\n  this.offset = offset\n}\nView3.prototype.get = function(i, j, k) {\n  return this.data[this.offset + i * this.stride[0] + j * this.stride[1] + k * this.stride[2]]\n}\nView3.prototype.set = function(i, j, k, v) {\n  return this.data[this.offset + i * this.stride[0] + j * this.stride[1] + k * this.stride[2]] = v\n}\nView3.prototype.hi = ViewN.prototype.hi\nView3.prototype.lo = ViewN.prototype.lo\nView3.prototype.step = ViewN.prototype.step\nView3.prototype.transpose = ViewN.prototype.transpose\nView3.prototype.pick = ViewN.prototype.pick\nView3.prototype.toString = ViewN.prototype.toString\n\n\nfunction CTOR(data, shape, stride, offset) {\n  switch(shape.length) {\n    case 0:   return new View0(data)\n    case 1:   return new View1(data, shape, stride, offset)\n    case 2:   return new View2(data, shape, stride, offset)\n    case 3:   return new View3(data, shape, stride, offset)\n    default:  return new ViewN(data, shape, stride, offset)\n  }\n}\n\nmodule.exports = CTOR\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray/lib/viewn.js\n ** module id = 12\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar cwise = require(\"cwise\")\nvar ndarray = require(\"ndarray\")\n\nvar assign_ops = {\n  add:  \"+\",\n  sub:  \"-\",\n  mul:  \"*\",\n  div:  \"/\",\n  mod:  \"%\",\n  band: \"&\",\n  bor:  \"|\",\n  bxor: \"^\",\n  lshift: \"<<\",\n  rshift: \">>\",\n  rrshift: \">>>\"\n};\n\n(function(){\n  for(var id in assign_ops) {\n    var op = assign_ops[id]\n    exports[id] = cwise({\n      args: [\"array\",\"array\",\"array\"],\n      body: Function(\"a\",\"b\",\"c\",\"a=b\"+op+\"c\")\n    })\n    exports[id+\"eq\"] = cwise({\n      args: [\"array\",\"array\"],\n      body: Function(\"a\",\"b\",\"a\"+op+\"=b\")\n    })\n    exports[id+\"s\"] = cwise({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: Function(\"a\",\"b\",\"s\",\"a=b\"+op+\"s\")\n    })\n    exports[id+\"seq\"] = cwise({\n      args: [\"array\",\"scalar\"],\n      body: Function(\"a\",\"s\",\"a\"+op+\"=s\")\n    })\n  }\n})()\n\nvar unary_ops = {\n  not: \"!\",\n  bnot: \"~\",\n  neg: \"-\",\n  recip: \"1.0/\"\n};\n\n(function(){\n  for(var id in unary_ops) {\n    var op = unary_ops[id]\n    exports[id] = cwise({\n      args: [\"array\", \"array\"],\n      body: Function(\"a\",\"b\",\"a=\"+op+\"b\")\n    })\n    exports[id+\"eq\"] = cwise({\n      args: [\"array\"],\n      body: Function(\"a\",\"a=\"+op+\"a\")\n    })\n  }\n})()\n\nvar binary_ops = {\n  and: \"&&\",\n  or: \"||\",\n  eq: \"===\",\n  neq: \"!==\",\n  lt: \"<\",\n  gt: \">\",\n  leq: \"<=\",\n  geq: \">=\"\n};\n\n(function() {\n  for(var id in binary_ops) {\n    var op = binary_ops[id]\n    exports[id] = cwise({\n      args: [\"array\",\"array\",\"array\"],\n      body: Function(\"a\", \"b\", \"c\", \"a=b\"+op+\"c\")\n    })\n    exports[id+\"s\"] = cwise({\n      args: [\"array\",\"array\",\"scalar\"],\n      body: Function(\"a\", \"b\", \"s\", \"a=b\"+op+\"s\")\n    })\n    exports[id+\"eq\"] = cwise({\n      args: [\"array\", \"array\"],\n      body: Function(\"a\", \"b\", \"a=a\"+op+\"b\")\n    })\n    exports[id+\"seq\"] = cwise({\n      args: [\"array\", \"scalar\"],\n      body: Function(\"a\", \"s\", \"a=a\"+op+\"s\")\n    })\n  }\n})()\n\nvar math_unary = [\n  \"abs\",\n  \"acos\",\n  \"asin\",\n  \"atan\",\n  \"ceil\",\n  \"cos\",\n  \"exp\",\n  \"floor\",\n  \"log\",\n  \"round\",\n  \"sin\",\n  \"sqrt\",\n  \"tan\"\n];\n\n(function() {\n  for(var i=0; i<math_unary.length; ++i) {\n    var f = math_unary[i]\n    exports[f] = cwise({\n                    args: [\"array\", \"array\"],\n                    pre: Function(\"this.func=Math.\"+f),\n                    body: function(a,b) {\n                      a = this.func(b)\n                    }\n                  })\n    exports[f+\"eq\"] = cwise({\n                      args: [\"array\"],\n                      pre: Function(\"this.func=Math.\"+f),\n                      body: function(a) {\n                        a = this.func(a)\n                      }\n                    })\n  }\n})()\n\nvar math_comm = [\n  \"max\",\n  \"min\"\n];\n(function(){\n  for(var i=0; i<math_comm.length; ++i) {\n    var f= math_comm[i]\n \n    exports[f] = cwise({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b,c) {\n                    a = this.func(b,c)\n                  }\n                })\n    exports[f+\"s\"] = cwise({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b,c) {\n                    a = this.func(b,c)\n                  }})\n    exports[f+\"eq\"] = cwise({ args:[\"array\", \"array\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b) {\n                    a = this.func(a,b)\n                  }})\n \n    exports[f+\"seq\"] = cwise({ args:[\"array\", \"scalar\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b) {\n                    a = this.func(a,b)\n                  }})\n  }\n})()\n\nvar math_noncomm = [\n  \"atan2\",\n  \"pow\"\n];\n\n(function(){\n  for(var i=0; i<math_noncomm.length; ++i) {\n    var f= math_noncomm[i]\n    exports[f] = cwise({ args:[\"array\", \"array\", \"array\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b,c) {\n                    a = this.func(b,c)\n                  }})\n                  \n    exports[f+\"s\"] = cwise({ args:[\"array\", \"array\", \"scalar\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b,c) {\n                    a = this.func(b,c)\n                  }})\n                  \n    exports[f+\"eq\"] = cwise({ args:[\"array\", \"array\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b) {\n                    a = this.func(a,b)\n                  }})\n                  \n    exports[f+\"seq\"] = cwise({ args:[\"array\", \"scalar\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b) {\n                    a = this.func(a,b)\n                  }})\n                  \n    exports[f+\"op\"] = cwise({ args:[\"array\", \"array\", \"array\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b,c) {\n                    a = this.func(c,b)\n                  }})\n                  \n    exports[f+\"ops\"] = cwise({ args:[\"array\", \"array\", \"scalar\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b,c) {\n                    a = this.func(c,b)\n                  }})\n                  \n    exports[f+\"opeq\"] = cwise({ args:[\"array\", \"array\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b) {\n                    a = this.func(b,a)\n                  }})\n                  \n    exports[f+\"opseq\"] = cwise({ args:[\"array\", \"scalar\"],\n                  pre: Function(\"this.func=Math.\"+f),\n                  body: function(a,b) {\n                    a = this.func(b,a)\n                  }})\n                  \n  }\n})()\n\nexports.any = cwise({ args:[\"array\"],\n  body: function(a) {\n    if(a) {\n      return true\n    }\n  },\n  post: function() {\n    return false\n  }})\n  \n\nexports.all = cwise({ args:[\"array\"],\n  body: function(a) {\n    if(!a) {\n      return false\n    }\n  },\n  post: function() {\n    return true\n  }})\n  \n\nexports.sum = cwise({ args:[\"array\"],\n  pre: function() {\n    this.sum = 0\n  },\n  body: function(a) {\n    this.sum += a\n  },\n  post: function() {\n    return this.sum\n  }})\n  \n\nexports.prod = cwise({ args:[\"array\"],\n  pre: function() {\n    this.prod = 1\n  },\n  body: function(a) {\n    this.prod *= a\n  },\n  post: function() {\n    return this.prod\n  }})\n  \n\nexports.norm2squared = cwise({ args:[\"array\"],\n  pre: function() {\n    this.sum = 0\n  },\n  body: function(a) {\n    this.sum += a*a\n  },\n  post: function() {\n    return this.sum\n  }})\n  \n\n\nexports.norm2 = cwise({ args:[\"array\"],\n  pre: function() {\n    this.sum = 0\n  },\n  body: function(a) {\n    this.sum += a*a\n  },\n  post: function() {\n    return Math.sqrt(this.sum)\n  }})\n  \n\nexports.norminf = cwise({ args:[\"array\"],\n  pre: function() {\n    this.n = 0\n  },\n  body: function(a) {\n    if(a<0){\n      if(-a<this.n){\n        this.n=-a\n      }\n    } else if(a>this.n){\n      s=a\n    }\n  },\n  post: function() {\n    return this.n\n  }})\n  \n\nexports.norm1 = cwise({ args:[\"array\"],\n  pre: function() {\n    this.sum = 0\n  },\n  body: function(a) {\n    this.sum += a < 0 ? -a : a\n  },\n  post: function() {\n    return this.sum\n  }})\n\n\nexports.sup = cwise({ args:[\"array\"],\n  pre: function() {\n    this.hi = Number.NEGATIVE_INFINITY\n  },\n  body: function(a) {\n    if(a > this.hi) {\n      this.hi = a\n    }\n  },\n  post: function() {\n    return this.hi\n  }})\n  \n\nexports.inf = cwise({ args:[\"array\"],\n  pre: function() {\n    this.lo = Number.POSITIVE_INFINITY\n  },\n  body: function(a) {\n    if(a < this.lo) {\n      this.lo = a\n    }\n  },\n  post: function() {\n    return this.lo\n  }})\n  \n\nexports.argmin = cwise({ args:[\"index\", \"array\"],\n  pre: function(i) {\n    this.min_v = Number.POSITIVE_INFINITY\n    this.min_i = i.slice(0)\n  },\n  body: function(i, a) {\n    if(a < this.min_v) {\n      this.min_v = a\n      for(var k=0; k<i.length; ++k) {\n        this.min_i[k] = i[k]\n      }\n    }\n  },\n  post: function() {\n    return this.min_i\n  }})\n  \n\nexports.argmax = cwise({ args:[\"index\", \"array\"],\n  pre: function(i) {\n    this.max_v = Number.NEGATIVE_INFINITY\n    this.max_i = i.slice(0)\n  },\n  body: function(i, a) {\n    if(a > this.max_v) {\n      this.max_v = a\n      for(var k=0; k<i.length; ++k) {\n        this.max_i[k] = i[k]\n      }\n    }\n  },\n  post: function() {\n    return this.max_i\n  }})\n  \n\nexports.random = cwise({ args:[\"array\"],\n  pre: function() {\n    this.rnd = Math.random\n  },\n  body: function(a) {\n    a = this.rnd()\n  }})\n  \n\nexports.assign = cwise({ args:[\"array\", \"array\"],\n  body: function(a,b) {\n    a = b\n  }})\n\nexports.assigns = cwise({ args:[\"array\", \"scalar\"],\n  body: function(a,b) {\n    a = b\n  }})\n\nexports.clone = function(array) {\n  var stride = new Array(array.shape.length)\n  var tsz = 1;\n  for(var i=array.shape.length-1; i>=0; --i) {\n    stride[i] = tsz\n    tsz *= array.shape[i]\n  }\n  var ndata = new array.data.constructor(array.data.slice(0, tsz*array.data.BYTES_PER_ELEMENT))\n  var result = ndarray(ndata, array.shape.slice(0), stride, 0)\n  return exports.assign(result, array)\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-ops/index.js\n ** module id = 13\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar Parser = require(\"./lib/parser.js\")\n  , createShim = require(\"./lib/shim.js\")\n\nvar REQUIRED_FIELDS = [ \"args\", \"body\" ]\nvar OPTIONAL_FIELDS = [ \"pre\", \"post\", \"printCode\" ]\n\nfunction CompiledProcedure() {\n  this.numArgs = 0\n  this.numArrayArgs = 0\n  this.numScalarArgs = 0\n  this.hasIndex = false\n  this.hasShape = false\n  this.hasReturn = false\n  this.pre = \"\"\n  this.body = \"\"\n  this.post = \"\"\n  this.unroll = 1\n  this.printCode = false\n}\n\nfunction compile(user_args) {\n  for(var id in user_args) {\n    if(REQUIRED_FIELDS.indexOf(id) < 0 &&\n       OPTIONAL_FIELDS.indexOf(id) < 0) {\n      throw new Error(\"Unknown argument '\"+id+\"' passed to expression compiler\")\n    }\n  }\n  for(var i=0; i<REQUIRED_FIELDS.length; ++i) {\n    if(!user_args[REQUIRED_FIELDS[i]]) {\n      throw new Error(\"Missing argument: \" + REQUIRED_FIELDS[i])\n    }\n  }\n  //Parse arguments\n  var proc = new CompiledProcedure()\n  var proc_args = user_args.args.slice(0)\n  var shim_args = []\n  for(var i=0; i<proc_args.length; ++i) {\n    switch(proc_args[i]) {\n      case \"array\":\n        shim_args.push(\"array\" + proc.numArrayArgs)\n        proc_args[i] += (proc.numArrayArgs++)\n      break\n      case \"scalar\":\n        shim_args.push(\"scalar\" + proc.numScalarArgs)\n        proc_args[i] += (proc.numScalarArgs++)\n      break\n      case \"index\":\n        proc.hasIndex = true\n      break\n      case \"shape\":\n        proc.hasShape = true\n      break\n      default:\n        throw new Error(\"Unknown argument types\")\n    }\n  }\n  if(proc.numArrayArgs <= 0) {\n    throw new Error(\"No array arguments specified\")\n  }\n  \n  //Parse blocks\n  var parser = new Parser(proc_args)\n    , pre = user_args.pre || null\n    , body = user_args.body\n    , post = user_args.post || null\n  parser.preprocess(pre)\n  parser.preprocess(body)\n  parser.preprocess(post)\n  proc.pre  = parser.preBlock() + \"\\n\" + parser.process(pre)\n  proc.body = parser.process(body)\n  proc.post = parser.process(post) + \"\\n\" + parser.postBlock()\n  proc.hasReturn = parser.hasReturn\n  \n  //Parse options\n  proc.printCode = user_args.printCode || false\n  \n  //Assemble shim\n  return createShim(shim_args, proc)\n}\n\nmodule.exports = compile\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/index.js\n ** module id = 14\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar falafel = require(\"falafel\")\n\nfunction isGlobal(identifier) {\n  if(typeof(window) !== \"undefined\") {\n    return identifier in window\n  } else if(typeof(GLOBAL) !== \"undefined\") {\n    return identifier in GLOBAL\n  } else {\n    return false\n  }\n}\n\nfunction getArgs(src) {\n  var args = []\n  falafel(src, function(node) {\n    var i\n    if(node.type === \"FunctionExpression\" &&\n       node.parent.parent.parent.type === \"Program\") {\n      args = new Array(node.params.length)\n      for(i=0; i<node.params.length; ++i) {\n        args[i] = node.params[i].name\n      }\n    }\n  })\n  return args\n}\n\nfunction Parser(args) {\n  this.args = args\n  this.this_vars = []\n  this.computed_this = false\n  this.prefix_count = 0\n  this.hasReturn = false\n}\n\n//Preprocessing pass is needed to explode the \"this\" object\nParser.prototype.preprocess = function(func) {\n  if(!func || this.computed_this) {\n    return\n  }\n  var src = \"(\" + func + \")()\"\n    , this_vars = this.this_vars\n    , computed_this = this.computed_this\n  falafel(src, function(node) {\n    var n\n    if(node.type === \"ThisExpression\") {\n      if(node.parent.type === \"MemberExpression\" && !node.parent.computed) {\n        n = node.parent.property.name\n        if(this_vars.indexOf(n) < 0) {\n          this_vars.push(n)\n        }\n      } else {\n        computed_this = true\n      }\n    }\n  })\n  if(computed_this) {\n    this.this_vars = []\n  }\n  this.computed_this = computed_this\n}\n\nParser.prototype.process = function(func) {\n  if(!func) {\n    return \"\"\n  }\n  var label = this.prefix_count++\n    , src = \"(\" + func + \")()\"\n    , block_args = getArgs(src)\n    , proc_args = this.args\n    , result = \"\"\n    , inline_prefix = \"inline\" + label + \"_\"\n    , hasReturn = this.hasReturn\n  falafel(src, function(node) {\n    var n, i, j\n    if(node.type === \"FunctionExpression\" &&\n       node.parent.parent.parent.type === \"Program\") {\n      result = node.body.source()\n    } else if(node.type === \"Identifier\") {\n      if(node.parent.type === \"MemberExpression\") {\n        if((node.parent.property === node && !node.parent.computed) ||\n           node.parent.object.type === \"ThisExpression\") {\n          return\n        }\n      }\n      n = node.name\n      i = block_args.indexOf(n)\n      if(i >= 0) {\n        if(i < proc_args.length) {\n          if(proc_args[i].indexOf(\"array\") === 0) {\n            j = parseInt(proc_args[i].substr(5))\n            node.update(\"arr\"+j+\"[ptr\"+j+\"]\")\n          } else if(proc_args[i] === \"shape\") {\n            node.update(\"inline_shape\")\n          } else {\n            node.update(proc_args[i])\n          }\n        } else {\n          node.update(inline_prefix + node.source())\n        }\n      } else if(isGlobal(n)) {\n        return\n      } else {\n        node.update(inline_prefix + node.source())\n      }\n    } else if(node.type === \"MemberExpression\") {\n      if(node.object.type === \"ThisExpression\") {\n        node.update(\"this_\" + node.property.source().trimLeft())\n      }\n    } else if(node.type === \"ThisExpression\") {\n      if(node.parent.type !== \"MemberExpression\") {\n        node.update(\"this_\")\n      }\n    } else if(node.type === \"ReturnStatement\") {\n      hasReturn = true\n    }\n  })\n  this.hasReturn = hasReturn\n  var prefix = \"\"\n  for(var i=this.args.length; i<block_args.length; ++i) {\n    prefix += \"var \" + block_args[i] + \"\\n\"\n  }\n  return prefix + result\n}\n\nParser.prototype.preBlock = function() {\n  if(this.computed_this) {\n    return \"var this_={}\"\n  } else if(this.this_vars.length > 0) {\n    return \"var this_\" + this.this_vars.join(\",this_\")\n  } else {\n    return \"\"\n  }\n}\n\nParser.prototype.postBlock = function() {\n  return \"\"\n}\n\nmodule.exports = Parser\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/lib/parser.js\n ** module id = 15\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar parse = require('esprima').parse;\nvar objectKeys = Object.keys || function (obj) {\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    return keys;\n};\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn);\n    for (var i = 0; i < xs.length; i++) {\n        fn.call(xs, xs[i], i, xs);\n    }\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nmodule.exports = function (src, opts, fn) {\n    if (typeof opts === 'function') {\n        fn = opts;\n        opts = {};\n    }\n    if (typeof src === 'object') {\n        opts = src;\n        src = opts.source;\n        delete opts.source;\n    }\n    src = src === undefined ? opts.source : src;\n    opts.range = true;\n    if (typeof src !== 'string') src = String(src);\n    \n    var ast = parse(src, opts);\n    \n    var result = {\n        chunks : src.split(''),\n        toString : function () { return result.chunks.join('') },\n        inspect : function () { return result.toString() }\n    };\n    var index = 0;\n    \n    (function walk (node, parent) {\n        insertHelpers(node, parent, result.chunks);\n        \n        forEach(objectKeys(node), function (key) {\n            if (key === 'parent') return;\n            \n            var child = node[key];\n            if (isArray(child)) {\n                forEach(child, function (c) {\n                    if (c && typeof c.type === 'string') {\n                        walk(c, node);\n                    }\n                });\n            }\n            else if (child && typeof child.type === 'string') {\n                insertHelpers(child, node, result.chunks);\n                walk(child, node);\n            }\n        });\n        fn(node);\n    })(ast, undefined);\n    \n    return result;\n};\n \nfunction insertHelpers (node, parent, chunks) {\n    if (!node.range) return;\n    \n    node.parent = parent;\n    \n    node.source = function () {\n        return chunks.slice(\n            node.range[0], node.range[1]\n        ).join('');\n    };\n    \n    if (node.update && typeof node.update === 'object') {\n        var prev = node.update;\n        forEach(objectKeys(prev), function (key) {\n            update[key] = prev[key];\n        });\n        node.update = update;\n    }\n    else {\n        node.update = update;\n    }\n    \n    function update (s) {\n        chunks[node.range[0]] = s;\n        for (var i = node.range[0] + 1; i < node.range[1]; i++) {\n            chunks[i] = '';\n        }\n    };\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/~/falafel/index.js\n ** module id = 16\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/*\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, createLiteral: true, generateStatement: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        buffer,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function sliceSource(from, to) {\n        return source.slice(from, to);\n    }\n\n    if (typeof 'esprima'[0] === 'undefined') {\n        sliceSource = function sliceArraySource(from, to) {\n            return source.slice(from, to).join('');\n        };\n    }\n\n    function isDecimalDigit(ch) {\n        return '0123456789'.indexOf(ch) >= 0;\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === ' ') || (ch === '\\u0009') || (ch === '\\u000B') ||\n            (ch === '\\u000C') || (ch === '\\u00A0') ||\n            (ch.charCodeAt(0) >= 0x1680 &&\n             '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === '\\n' || ch === '\\r' || ch === '\\u2028' || ch === '\\u2029');\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch >= '0') && (ch <= '9')) ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n\n        // Future reserved words.\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n\n        // Strict Mode reserved words.\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        var keyword = false;\n        switch (id.length) {\n        case 2:\n            keyword = (id === 'if') || (id === 'in') || (id === 'do');\n            break;\n        case 3:\n            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');\n            break;\n        case 4:\n            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');\n            break;\n        case 5:\n            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');\n            break;\n        case 6:\n            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');\n            break;\n        case 7:\n            keyword = (id === 'default') || (id === 'finally');\n            break;\n        case 8:\n            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');\n            break;\n        case 10:\n            keyword = (id === 'instanceof');\n            break;\n        }\n\n        if (keyword) {\n            return true;\n        }\n\n        switch (id) {\n        // Future reserved words.\n        // 'const' is specialized as Keyword in V8.\n        case 'const':\n            return true;\n\n        // For compatiblity to SpiderMonkey and ES.next\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        return isFutureReservedWord(id);\n    }\n\n    // 7.4 Comments\n\n    function skipComment() {\n        var ch, blockComment, lineComment;\n\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    lineComment = false;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            ++index;\n                            blockComment = false;\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    index += 2;\n                    lineComment = true;\n                } else if (ch === '*') {\n                    index += 2;\n                    blockComment = true;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanIdentifier() {\n        var ch, start, id, restore;\n\n        ch = source[index];\n        if (!isIdentifierStart(ch)) {\n            return;\n        }\n\n        start = index;\n        if (ch === '\\\\') {\n            ++index;\n            if (source[index] !== 'u') {\n                return;\n            }\n            ++index;\n            restore = index;\n            ch = scanHexEscape('u');\n            if (ch) {\n                if (ch === '\\\\' || !isIdentifierStart(ch)) {\n                    return;\n                }\n                id = ch;\n            } else {\n                index = restore;\n                id = 'u';\n            }\n        } else {\n            id = source[index++];\n        }\n\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            if (ch === '\\\\') {\n                ++index;\n                if (source[index] !== 'u') {\n                    return;\n                }\n                ++index;\n                restore = index;\n                ch = scanHexEscape('u');\n                if (ch) {\n                    if (ch === '\\\\' || !isIdentifierPart(ch)) {\n                        return;\n                    }\n                    id += ch;\n                } else {\n                    index = restore;\n                    id += 'u';\n                }\n            } else {\n                id += source[index++];\n            }\n        }\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            return {\n                type: Token.Identifier,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (isKeyword(id)) {\n            return {\n                type: Token.Keyword,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.1 Null Literals\n\n        if (id === 'null') {\n            return {\n                type: Token.NullLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.2 Boolean Literals\n\n        if (id === 'true' || id === 'false') {\n            return {\n                type: Token.BooleanLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        return {\n            type: Token.Identifier,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        // Check for most common single-character punctuators.\n\n        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Dot (.) can also start a floating-point number, hence the need\n        // to check the next character.\n\n        ch2 = source[index + 1];\n        if (ch1 === '.' && !isDecimalDigit(ch2)) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Peek more characters.\n\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '===',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '!==',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 2-character punctuators: <= >= == != ++ -- << >> && ||\n        // += -= *= %= &= |= ^= /=\n\n        if (ch2 === '=') {\n            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            if ('+-<>&|'.indexOf(ch2) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // The remaining 1-character punctuators.\n\n        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isHexDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 16),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                } else if (isOctalDigit(ch)) {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 8),\n                        octal: true,\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                }\n\n                // decimal number starts with '0' such as '09' is illegal.\n                if (isDecimalDigit(ch)) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n\n            ch = source[index];\n            if (isDecimalDigit(ch)) {\n                number += source[index++];\n                while (index < length) {\n                    ch = source[index];\n                    if (!isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += source[index++];\n                }\n            } else {\n                ch = 'character ' + ch;\n                if (index >= length) {\n                    ch = '<end>';\n                }\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (index < length) {\n            ch = source[index];\n            if (isIdentifierStart(ch)) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch)) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch)) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        buffer = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        str += '\\\\u';\n                        for (; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advance() {\n        var ch, token;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        token = scanPunctuator();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        ch = source[index];\n\n        if (ch === '\\'' || ch === '\"') {\n            return scanStringLiteral();\n        }\n\n        if (ch === '.' || isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        token = scanIdentifier();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function lex() {\n        var token;\n\n        if (buffer) {\n            index = buffer.range[1];\n            lineNumber = buffer.lineNumber;\n            lineStart = buffer.lineStart;\n            token = buffer;\n            buffer = null;\n            return token;\n        }\n\n        buffer = null;\n        return advance();\n    }\n\n    function lookahead() {\n        var pos, line, start;\n\n        if (buffer !== null) {\n            return buffer;\n        }\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        buffer = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return buffer;\n    }\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    return args[index] || '';\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        var token = lookahead();\n        return token.type === Token.Punctuator && token.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        var token = lookahead();\n        return token.type === Token.Keyword && token.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var token = lookahead(),\n            op = token.value;\n\n        if (token.type !== Token.Punctuator) {\n            return false;\n        }\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var token, line;\n\n        // Catch the very common case first.\n        if (source[index] === ';') {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        token = lookahead();\n        if (token.type !== Token.EOF && !match('}')) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return {\n            type: Syntax.ArrayExpression,\n            elements: elements\n        };\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body;\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: null,\n            params: param,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseObjectPropertyKey() {\n        var token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, param;\n\n        token = lookahead();\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                return {\n                    type: Syntax.Property,\n                    key: key,\n                    value: parsePropertyFunction([]),\n                    kind: 'get'\n                };\n            } else if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead();\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction([]),\n                        kind: 'set'\n                    };\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction(param, token),\n                        kind: 'set'\n                    };\n                }\n            } else {\n                expect(':');\n                return {\n                    type: Syntax.Property,\n                    key: id,\n                    value: parseAssignmentExpression(),\n                    kind: 'init'\n                };\n            }\n        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: parseAssignmentExpression(),\n                kind: 'init'\n            };\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n            if (Object.prototype.hasOwnProperty.call(map, name)) {\n                if (map[name] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[name] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[name] |= kind;\n            } else {\n                map[name] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return {\n            type: Syntax.ObjectExpression,\n            properties: properties\n        };\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var token = lookahead(),\n            type = token.type;\n\n        if (type === Token.Identifier) {\n            return {\n                type: Syntax.Identifier,\n                name: lex().value\n            };\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(lex());\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                return {\n                    type: Syntax.ThisExpression\n                };\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            lex();\n            token.value = (token.value === 'true');\n            return createLiteral(token);\n        }\n\n        if (type === Token.NullLiteral) {\n            lex();\n            token.value = null;\n            return createLiteral(token);\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            return createLiteral(scanRegExp());\n        }\n\n        return throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var expr;\n\n        expectKeyword('new');\n\n        expr = {\n            type: Syntax.NewExpression,\n            callee: parseLeftHandSideExpression(),\n            'arguments': []\n        };\n\n        if (match('(')) {\n            expr['arguments'] = parseArguments();\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n\n    function parseLeftHandSideExpression() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr = parseLeftHandSideExpressionAllowCall(), token;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: lex().value,\n                argument: expr,\n                prefix: false\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: token.value,\n                argument: expr,\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    // 11.5 Multiplicative Operators\n\n    function parseMultiplicativeExpression() {\n        var expr = parseUnaryExpression();\n\n        while (match('*') || match('/') || match('%')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseUnaryExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.6 Additive Operators\n\n    function parseAdditiveExpression() {\n        var expr = parseMultiplicativeExpression();\n\n        while (match('+') || match('-')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseMultiplicativeExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.7 Bitwise Shift Operators\n\n    function parseShiftExpression() {\n        var expr = parseAdditiveExpression();\n\n        while (match('<<') || match('>>') || match('>>>')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAdditiveExpression()\n            };\n        }\n\n        return expr;\n    }\n    // 11.8 Relational Operators\n\n    function parseRelationalExpression() {\n        var expr, previousAllowIn;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        expr = parseShiftExpression();\n\n        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseShiftExpression()\n            };\n        }\n\n        state.allowIn = previousAllowIn;\n        return expr;\n    }\n\n    // 11.9 Equality Operators\n\n    function parseEqualityExpression() {\n        var expr = parseRelationalExpression();\n\n        while (match('==') || match('!=') || match('===') || match('!==')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseRelationalExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.10 Binary Bitwise Operators\n\n    function parseBitwiseANDExpression() {\n        var expr = parseEqualityExpression();\n\n        while (match('&')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '&',\n                left: expr,\n                right: parseEqualityExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseXORExpression() {\n        var expr = parseBitwiseANDExpression();\n\n        while (match('^')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '^',\n                left: expr,\n                right: parseBitwiseANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseORExpression() {\n        var expr = parseBitwiseXORExpression();\n\n        while (match('|')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '|',\n                left: expr,\n                right: parseBitwiseXORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.11 Binary Logical Operators\n\n    function parseLogicalANDExpression() {\n        var expr = parseBitwiseORExpression();\n\n        while (match('&&')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '&&',\n                left: expr,\n                right: parseBitwiseORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseLogicalORExpression() {\n        var expr = parseLogicalANDExpression();\n\n        while (match('||')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '||',\n                left: expr,\n                right: parseLogicalANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent;\n\n        expr = parseLogicalORExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n\n            expr = {\n                type: Syntax.ConditionalExpression,\n                test: expr,\n                consequent: consequent,\n                alternate: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr;\n\n        token = lookahead();\n        expr = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            expr = {\n                type: Syntax.AssignmentExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = {\n                type: Syntax.SequenceExpression,\n                expressions: [ expr ]\n            };\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n\n        }\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block;\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return {\n            type: Syntax.BlockStatement,\n            body: block\n        };\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id = parseVariableIdentifier(),\n            init = null;\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return {\n            type: Syntax.VariableDeclarator,\n            id: id,\n            init: init\n        };\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: 'var'\n        };\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations;\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: kind\n        };\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n\n        return {\n            type: Syntax.EmptyStatement\n        };\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return {\n            type: Syntax.IfStatement,\n            test: test,\n            consequent: consequent,\n            alternate: alternate\n        };\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return {\n            type: Syntax.DoWhileStatement,\n            body: body,\n            test: test\n        };\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return {\n            type: Syntax.WhileStatement,\n            test: test,\n            body: body\n        };\n    }\n\n    function parseForVariableDeclaration() {\n        var token = lex();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: parseVariableDeclarationList(),\n            kind: token.value\n        };\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        }\n\n        return {\n            type: Syntax.ForInStatement,\n            left: left,\n            right: right,\n            body: body,\n            each: false\n        };\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var token, label = null;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return {\n            type: Syntax.ContinueStatement,\n            label: label\n        };\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var token, label = null;\n\n        expectKeyword('break');\n\n        // Optimize the most common form: 'break;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return {\n            type: Syntax.BreakStatement,\n            label: label\n        };\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var token, argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source[index] === ' ') {\n            if (isIdentifierStart(source[index + 1])) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return {\n                    type: Syntax.ReturnStatement,\n                    argument: argument\n                };\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: null\n            };\n        }\n\n        if (!match(';')) {\n            token = lookahead();\n            if (!match('}') && token.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ReturnStatement,\n            argument: argument\n        };\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return {\n            type: Syntax.WithStatement,\n            object: object,\n            body: body\n        };\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            statement;\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            consequent.push(statement);\n        }\n\n        return {\n            type: Syntax.SwitchCase,\n            test: test,\n            consequent: consequent\n        };\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return {\n            type: Syntax.SwitchStatement,\n            discriminant: discriminant,\n            cases: cases\n        };\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ThrowStatement,\n            argument: argument\n        };\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param;\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead());\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n\n        return {\n            type: Syntax.CatchClause,\n            param: param,\n            body: parseBlock()\n        };\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return {\n            type: Syntax.TryStatement,\n            block: block,\n            guardedHandlers: [],\n            handlers: handlers,\n            finalizer: finalizer\n        };\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.DebuggerStatement\n        };\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var token = lookahead(),\n            expr,\n            labeledBody;\n\n        if (token.type === Token.EOF) {\n            throwUnexpected(token);\n        }\n\n        if (token.type === Token.Punctuator) {\n            switch (token.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[expr.name] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[expr.name];\n\n            return {\n                type: Syntax.LabeledStatement,\n                label: expr,\n                body: labeledBody\n            };\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;\n\n        expect('{');\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return {\n            type: Syntax.BlockStatement,\n            body: sourceElements\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;\n\n        expectKeyword('function');\n        token = lookahead();\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionDeclaration,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead();\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        var token = lookahead();\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(token.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (token.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var program;\n        strict = false;\n        program = {\n            type: Syntax.Program,\n            body: parseSourceElements()\n        };\n        return program;\n    }\n\n    // The following functions are needed only when the option to preserve\n    // the comments is active.\n\n    function addComment(type, value, start, end, loc) {\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (extra.comments.length > 0) {\n            if (extra.comments[extra.comments.length - 1].range[1] > start) {\n                return;\n            }\n        }\n\n        extra.comments.push({\n            type: type,\n            value: value,\n            range: [start, end],\n            loc: loc\n        });\n    }\n\n    function scanComment() {\n        var comment, ch, loc, start, blockComment, lineComment;\n\n        comment = '';\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    lineComment = false;\n                    addComment('Line', comment, start, index - 1, loc);\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                    comment = '';\n                } else if (index >= length) {\n                    lineComment = false;\n                    comment += ch;\n                    loc.end = {\n                        line: lineNumber,\n                        column: length - lineStart\n                    };\n                    addComment('Line', comment, start, length, loc);\n                } else {\n                    comment += ch;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                        comment += '\\r\\n';\n                    } else {\n                        comment += ch;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    comment += ch;\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            comment = comment.substr(0, comment.length - 1);\n                            blockComment = false;\n                            ++index;\n                            loc.end = {\n                                line: lineNumber,\n                                column: index - lineStart\n                            };\n                            addComment('Block', comment, start, index, loc);\n                            comment = '';\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart\n                        }\n                    };\n                    start = index;\n                    index += 2;\n                    lineComment = true;\n                    if (index >= length) {\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        lineComment = false;\n                        addComment('Line', comment, start, index, loc);\n                    }\n                } else if (ch === '*') {\n                    start = index;\n                    index += 2;\n                    blockComment = true;\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart - 2\n                        }\n                    };\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function filterCommentLocation() {\n        var i, entry, comment, comments = [];\n\n        for (i = 0; i < extra.comments.length; ++i) {\n            entry = extra.comments[i];\n            comment = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                comment.range = entry.range;\n            }\n            if (extra.loc) {\n                comment.loc = entry.loc;\n            }\n            comments.push(comment);\n        }\n\n        extra.comments = comments;\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = sliceSource(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        // Pop the previous token, which is likely '/' or '/='\n        if (extra.tokens.length > 0) {\n            token = extra.tokens[extra.tokens.length - 1];\n            if (token.range[0] === pos && token.type === 'Punctuator') {\n                if (token.value === '/' || token.value === '/=') {\n                    extra.tokens.pop();\n                }\n            }\n        }\n\n        extra.tokens.push({\n            type: 'RegularExpression',\n            value: regex.literal,\n            range: [pos, index],\n            loc: loc\n        });\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function createLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value\n        };\n    }\n\n    function createRawLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value,\n            raw: sliceSource(token.range[0], token.range[1])\n        };\n    }\n\n    function createLocationMarker() {\n        var marker = {};\n\n        marker.range = [index, index];\n        marker.loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            },\n            end: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        marker.end = function () {\n            this.range[1] = index;\n            this.loc.end.line = lineNumber;\n            this.loc.end.column = index - lineStart;\n        };\n\n        marker.applyGroup = function (node) {\n            if (extra.range) {\n                node.groupRange = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.groupLoc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        marker.apply = function (node) {\n            if (extra.range) {\n                node.range = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        return marker;\n    }\n\n    function trackGroupExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        marker.end();\n        marker.applyGroup(expr);\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpressionAllowCall() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function filterGroup(node) {\n        var n, i, entry;\n\n        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};\n        for (i in node) {\n            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {\n                entry = node[i];\n                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {\n                    n[i] = entry;\n                } else {\n                    n[i] = filterGroup(entry);\n                }\n            }\n        }\n        return n;\n    }\n\n    function wrapTrackingFunction(range, loc) {\n\n        return function (parseFunction) {\n\n            function isBinary(node) {\n                return node.type === Syntax.LogicalExpression ||\n                    node.type === Syntax.BinaryExpression;\n            }\n\n            function visit(node) {\n                var start, end;\n\n                if (isBinary(node.left)) {\n                    visit(node.left);\n                }\n                if (isBinary(node.right)) {\n                    visit(node.right);\n                }\n\n                if (range) {\n                    if (node.left.groupRange || node.right.groupRange) {\n                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];\n                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];\n                        node.range = [start, end];\n                    } else if (typeof node.range === 'undefined') {\n                        start = node.left.range[0];\n                        end = node.right.range[1];\n                        node.range = [start, end];\n                    }\n                }\n                if (loc) {\n                    if (node.left.groupLoc || node.right.groupLoc) {\n                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;\n                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;\n                        node.loc = {\n                            start: start,\n                            end: end\n                        };\n                    } else if (typeof node.loc === 'undefined') {\n                        node.loc = {\n                            start: node.left.loc.start,\n                            end: node.right.loc.end\n                        };\n                    }\n                }\n            }\n\n            return function () {\n                var marker, node;\n\n                skipComment();\n\n                marker = createLocationMarker();\n                node = parseFunction.apply(null, arguments);\n                marker.end();\n\n                if (range && typeof node.range === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (loc && typeof node.loc === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (isBinary(node)) {\n                    visit(node);\n                }\n\n                return node;\n            };\n        };\n    }\n\n    function patch() {\n\n        var wrapTracking;\n\n        if (extra.comments) {\n            extra.skipComment = skipComment;\n            skipComment = scanComment;\n        }\n\n        if (extra.raw) {\n            extra.createLiteral = createLiteral;\n            createLiteral = createRawLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n\n            extra.parseGroupExpression = parseGroupExpression;\n            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;\n            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;\n            parseGroupExpression = trackGroupExpression;\n            parseLeftHandSideExpression = trackLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;\n\n            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);\n\n            extra.parseAdditiveExpression = parseAdditiveExpression;\n            extra.parseAssignmentExpression = parseAssignmentExpression;\n            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;\n            extra.parseBitwiseORExpression = parseBitwiseORExpression;\n            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;\n            extra.parseBlock = parseBlock;\n            extra.parseFunctionSourceElements = parseFunctionSourceElements;\n            extra.parseCatchClause = parseCatchClause;\n            extra.parseComputedMember = parseComputedMember;\n            extra.parseConditionalExpression = parseConditionalExpression;\n            extra.parseConstLetDeclaration = parseConstLetDeclaration;\n            extra.parseEqualityExpression = parseEqualityExpression;\n            extra.parseExpression = parseExpression;\n            extra.parseForVariableDeclaration = parseForVariableDeclaration;\n            extra.parseFunctionDeclaration = parseFunctionDeclaration;\n            extra.parseFunctionExpression = parseFunctionExpression;\n            extra.parseLogicalANDExpression = parseLogicalANDExpression;\n            extra.parseLogicalORExpression = parseLogicalORExpression;\n            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;\n            extra.parseNewExpression = parseNewExpression;\n            extra.parseNonComputedProperty = parseNonComputedProperty;\n            extra.parseObjectProperty = parseObjectProperty;\n            extra.parseObjectPropertyKey = parseObjectPropertyKey;\n            extra.parsePostfixExpression = parsePostfixExpression;\n            extra.parsePrimaryExpression = parsePrimaryExpression;\n            extra.parseProgram = parseProgram;\n            extra.parsePropertyFunction = parsePropertyFunction;\n            extra.parseRelationalExpression = parseRelationalExpression;\n            extra.parseStatement = parseStatement;\n            extra.parseShiftExpression = parseShiftExpression;\n            extra.parseSwitchCase = parseSwitchCase;\n            extra.parseUnaryExpression = parseUnaryExpression;\n            extra.parseVariableDeclaration = parseVariableDeclaration;\n            extra.parseVariableIdentifier = parseVariableIdentifier;\n\n            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);\n            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);\n            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);\n            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);\n            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);\n            parseBlock = wrapTracking(extra.parseBlock);\n            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);\n            parseCatchClause = wrapTracking(extra.parseCatchClause);\n            parseComputedMember = wrapTracking(extra.parseComputedMember);\n            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);\n            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);\n            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);\n            parseExpression = wrapTracking(extra.parseExpression);\n            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);\n            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);\n            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);\n            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);\n            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);\n            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);\n            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);\n            parseNewExpression = wrapTracking(extra.parseNewExpression);\n            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);\n            parseObjectProperty = wrapTracking(extra.parseObjectProperty);\n            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);\n            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);\n            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);\n            parseProgram = wrapTracking(extra.parseProgram);\n            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);\n            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);\n            parseStatement = wrapTracking(extra.parseStatement);\n            parseShiftExpression = wrapTracking(extra.parseShiftExpression);\n            parseSwitchCase = wrapTracking(extra.parseSwitchCase);\n            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);\n            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);\n            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);\n        }\n\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.skipComment === 'function') {\n            skipComment = extra.skipComment;\n        }\n\n        if (extra.raw) {\n            createLiteral = extra.createLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n            parseAdditiveExpression = extra.parseAdditiveExpression;\n            parseAssignmentExpression = extra.parseAssignmentExpression;\n            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;\n            parseBitwiseORExpression = extra.parseBitwiseORExpression;\n            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;\n            parseBlock = extra.parseBlock;\n            parseFunctionSourceElements = extra.parseFunctionSourceElements;\n            parseCatchClause = extra.parseCatchClause;\n            parseComputedMember = extra.parseComputedMember;\n            parseConditionalExpression = extra.parseConditionalExpression;\n            parseConstLetDeclaration = extra.parseConstLetDeclaration;\n            parseEqualityExpression = extra.parseEqualityExpression;\n            parseExpression = extra.parseExpression;\n            parseForVariableDeclaration = extra.parseForVariableDeclaration;\n            parseFunctionDeclaration = extra.parseFunctionDeclaration;\n            parseFunctionExpression = extra.parseFunctionExpression;\n            parseGroupExpression = extra.parseGroupExpression;\n            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;\n            parseLogicalANDExpression = extra.parseLogicalANDExpression;\n            parseLogicalORExpression = extra.parseLogicalORExpression;\n            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;\n            parseNewExpression = extra.parseNewExpression;\n            parseNonComputedProperty = extra.parseNonComputedProperty;\n            parseObjectProperty = extra.parseObjectProperty;\n            parseObjectPropertyKey = extra.parseObjectPropertyKey;\n            parsePrimaryExpression = extra.parsePrimaryExpression;\n            parsePostfixExpression = extra.parsePostfixExpression;\n            parseProgram = extra.parseProgram;\n            parsePropertyFunction = extra.parsePropertyFunction;\n            parseRelationalExpression = extra.parseRelationalExpression;\n            parseStatement = extra.parseStatement;\n            parseShiftExpression = extra.parseShiftExpression;\n            parseSwitchCase = extra.parseSwitchCase;\n            parseUnaryExpression = extra.parseUnaryExpression;\n            parseVariableDeclaration = extra.parseVariableDeclaration;\n            parseVariableIdentifier = extra.parseVariableIdentifier;\n        }\n\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    function stringToArray(str) {\n        var length = str.length,\n            result = [],\n            i;\n        for (i = 0; i < length; ++i) {\n            result[i] = str.charAt(i);\n        }\n        return result;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        buffer = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.raw = (typeof options.raw === 'boolean') && options.raw;\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n\n                // Force accessing the characters via an array.\n                if (typeof source[0] === 'undefined') {\n                    source = stringToArray(code);\n                }\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                filterCommentLocation();\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n            if (extra.range || extra.loc) {\n                program.body = filterGroup(program.body);\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with package.json.\n    exports.version = '1.0.4';\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/~/falafel/~/esprima/esprima.js\n ** module id = 17\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar generate = require(\"./generate.js\")\n\n//Reuse stack across all shims\nvar STACK = new Int32Array(1024)\n\nfunction Shim(procedure) {\n  this.memoized = {}\n  this.procedure = procedure\n}\n\nShim.prototype.checkShape = function(a, b) {\n  if(a.length !== b.length) {\n    throw new Error(\"Shape mismatch\")\n  }\n  for(var i=a.length-1; i>=0; --i) {\n    if(a[i] !== b[i]) {\n      throw new Error(\"Shape mismatch\")\n    }\n  }\n}\n\nShim.prototype.getStack = function(size) {\n  if(size < STACK.length) {\n    return STACK\n  }\n  STACK = new Int32Array(size)\n  return STACK\n}\n\nfunction compare1st(a,b) { return a[0] - b[0]; }\n\nShim.prototype.getOrder = function(stride) {\n  var zipped = new Array(stride.length)\n  for(var i=0; i<stride.length; ++i) {\n    zipped[i] = [Math.abs(stride[i]), i]\n  }\n  zipped.sort(compare1st)\n  var unzipped = new Array(stride.length)\n  for(var i=0; i<stride.length; ++i) {\n    unzipped[i] = zipped[i][1]\n  }\n  return unzipped\n}\n\nShim.prototype.getProc = function(orders) {\n  var proc_name = orders.join(\"|\")\n    , proc = this.memoized[proc_name]\n  if(!proc) {\n    proc = generate(orders, this.procedure)\n    this.memoized[proc_name] = proc\n  }\n  return proc\n}\n\nfunction createShim(shim_args, procedure) {\n  var code = [\"\\\"use strict\\\"\"], i\n  //Check shapes\n  for(i=1; i<procedure.numArrayArgs; ++i) {\n    code.push(\"this.checkShape(array0.shape,array\"+i+\".shape)\")\n  }\n  //Load/lazily generate procedure based on array ordering\n  code.push(\"var proc = this.getProc([\")\n  for(i=0; i<procedure.numArrayArgs; ++i) {\n    code.push((i>0 ? \",\" : \"\") + \"this.getOrder(array\"+i+\".stride)\")\n  }\n  code.push(\"])\")\n  //Call procedure\n  if(procedure.hasReturn) {\n    code.push(\"return proc(\")\n  } else {\n    code.push(\"proc(\")\n  }\n  code.push(\"this.getStack(\" + procedure.numArrayArgs + \"*(array0.shape.length*32)), array0.shape.slice(0)\")\n  //Bind array arguments\n  for(i=0; i<procedure.numArrayArgs; ++i) {\n    code.push(\",array\" + i + \".data\")\n    code.push(\",array\" + i + \".offset\")\n    code.push(\",array\" + i + \".stride\")\n  }\n  //Bind scalar arguments\n  for(var i=0; i<procedure.numScalarArgs; ++i) {\n    code.push(\",scalar\"+i)\n  }\n  code.push(\")\")\n  if(!procedure.hasReturn) {\n    code.push(\"return array0\")\n  }\n  //Create the shim\n  shim_args.push(code.join(\"\\n\"))\n  var result = Function.apply(null, shim_args)\n  if(procedure.printCode) {\n    console.log(\"Generated shim:\", result + \"\")\n  }\n  return result.bind(new Shim(procedure))\n}\n\nmodule.exports = createShim\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/lib/shim.js\n ** module id = 18\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar RECURSION_LIMIT = 32\n\nfunction innerFill(order, procedure) {\n  var dimension = order.length\n    , nargs = procedure.numArrayArgs\n    , has_index = procedure.hasIndex\n    , code = []\n    , idx=0, pidx=0, i, j\n  for(i=0; i<dimension; ++i) {\n    code.push(\"var i\"+i+\"=0;\")\n  }\n  //Compute scan deltas\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx\n      idx = order[i]\n      if(i === 0) {\n        code.push(\"var d\"+j+\"s\"+i+\"=stride\"+j+\"[\"+idx+\"]|0;\")\n      } else {\n        code.push(\"var d\"+j+\"s\"+i+\"=(stride\"+j+\"[\"+idx+\"]-shape[\"+pidx+\"]*stride\"+j+\"[\"+pidx+\"])|0;\")\n      }\n    }\n  }\n  //Outer scan loop\n  for(i=dimension-1; i>=0; --i) {\n    idx = order[i]\n    code.push(\"for(i\"+i+\"=shape[\"+idx+\"]|0;--i\"+i+\">=0;){\")\n  }\n  //Push body of inner loop\n  code.push(procedure.body)\n  //Advance scan pointers\n  for(i=0; i<dimension; ++i) {\n    pidx = idx\n    idx = order[i]\n    for(j=0; j<nargs; ++j) {\n      code.push(\"ptr\"+j+\"+=d\"+j+\"s\"+i)\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push(\"index[\"+pidx+\"]-=shape[\"+pidx+\"]\")\n      }\n      code.push(\"++index[\"+idx+\"]\")\n    }\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\nfunction outerFill(matched, order, procedure) {\n  var dimension = order.length\n    , nargs = procedure.numArrayArgs\n    , has_index = procedure.hasIndex\n    , code = []\n    , static_args = dimension\n    , index_start = nargs + static_args\n    , frame_size = index_start + (has_index ? dimension : 0)\n    , i\n  \n  //Initiaize variables\n  code.push(\"var i=0,l=0,v=0,d=0,sp=0\")\n  \n  //Begin recursion\n  code.push(\"while(true){\")\n    \n    //Walk over runs to get bounds\n    code.push(\"l=\"+RECURSION_LIMIT)\n    code.push(\"v=\"+RECURSION_LIMIT)\n    code.push(\"d=\"+matched)\n  \n    for(i=matched; i<dimension; ++i) {\n      code.push(\"if(shape[\"+i+\"]>l){\")\n        code.push(\"v=l|0\")\n        code.push(\"l=shape[\"+i+\"]|0\")\n        code.push(\"d=\"+i+\"|0\")\n      code.push(\"}else if(shape[\"+i+\"]>v){\")\n        code.push(\"v=shape[\"+i+\"]|0\")\n      code.push(\"}\")\n    }\n  \n    code.push(\"if(l<=\"+RECURSION_LIMIT+\"){\")\n      code.push(innerFill(order, procedure))\n    code.push(\"} else {\")\n  \n      //Round v to previous power of 2\n      code.push(\"v=(v>>>1)-1\")\n      code.push(\"for(i=1;i<=16;i<<=1){v|=v>>>i}\")\n      code.push(\"++v\")\n      code.push(\"if(v<\"+RECURSION_LIMIT+\") v=\"+RECURSION_LIMIT)\n  \n      //Set shape\n      code.push(\"i=shape[d]\")\n      code.push(\"shape[d]=v\")\n  \n      //Fill across row\n      code.push(\"for(;i>=v;i-=v){\")\n        for(i=0; i<dimension; ++i) {\n          code.push(\"STACK[sp+\"+i+\"]=shape[\"+i+\"]\")\n        }\n        for(i=0; i<nargs; ++i) {\n          code.push(\"STACK[sp+\"+(i+static_args)+\"]=ptr\"+i+\"|0\")\n        }\n        if(has_index) {\n          for(i=0; i<dimension; ++i) {\n            code.push(\"STACK[sp+\"+(i+index_start)+\"]=index[\"+i+\"]\")\n          }\n          code.push(\"index[d]+=v\")\n        }\n        for(i=0; i<nargs; ++i) {\n          code.push(\"ptr\"+i+\"+=(v*stride\"+i+\"[d])|0\")\n        }\n        code.push(\"sp+=\"+frame_size)\n      code.push(\"}\")\n  \n      //Handle edge case\n      code.push(\"if(i>0){\")\n        code.push(\"shape[d]=i\")\n        for(i=0; i<dimension; ++i) {\n          code.push(\"STACK[sp+\"+i+\"]=shape[\"+i+\"]\")\n        }\n        for(i=0; i<nargs; ++i) {\n          code.push(\"STACK[sp+\"+(i+static_args)+\"]=ptr\"+i+\"|0\")\n        }\n        if(has_index) {\n          for(i=0; i<dimension; ++i) {\n            code.push(\"STACK[sp+\"+(i+index_start)+\"]=index[\"+i+\"]\")\n          }\n        }\n        code.push(\"sp+=\"+frame_size)\n      code.push(\"}\")\n    code.push(\"}\")\n  \n    //Pop previous state\n    code.push(\"if(sp<=0){\")\n      code.push(\"break\")\n    code.push(\"}\")\n    code.push(\"sp-=\"+frame_size)\n    for(i=0; i<dimension; ++i) {\n      code.push(\"shape[\"+i+\"]=STACK[sp+\"+i+\"]\")\n    }\n    for(i=0; i<nargs; ++i) {\n      code.push(\"ptr\"+i+\"=STACK[sp+\"+(i+static_args)+\"]\")\n    }\n    if(has_index) {\n      for(i=0; i<dimension; ++i) {\n        code.push(\"index[\"+i+\"]=STACK[sp+\"+(i+index_start)+\"]\")\n      }\n    }\n code.push(\"}\")\n return code.join(\"\\n\")\n}\n\nfunction majorOrder(orders) {\n  return orders[0]\n}\n\nfunction generate(orders, procedure) {\n  var order = majorOrder(orders)\n    , dimension = orders[0].length\n    , nargs = procedure.numArrayArgs\n    , code = ['\"use strict\"']\n    , matched, i, j\n    , arglist = [ \"STACK\", \"shape\" ]\n  //Create procedure arguments\n  for(i = 0; i<nargs; ++i) {\n    arglist.push(\"arr\" + i)\n    arglist.push(\"ptr\" + i)\n    arglist.push(\"stride\" + i)\n    code.push(\"ptr\"+i+\"|=0\")\n    for(j = 0; j<dimension; ++j) {\n      code.push(\"stride\"+i+\"[\"+j+\"]|=0\")\n    }\n  }\n  for(i = 0; i<dimension; ++i) {\n    code.push(\"shape[\"+i+\"]|=0\")\n  }\n  for(i = 0; i<procedure.numScalarArgs; ++i) {\n    arglist.push(\"scalar\"+i)\n  }\n  if(procedure.hasIndex) {\n    code.push(\"var index=[\")\n    for(i=0; i<dimension; ++i) {\n      code.push((i > 0) ? \",0\":\"0\")\n    }\n    code.push(\"]\")\n  }\n  if(procedure.hasShape) {\n    code.push(\"var inline_shape=shape.slice(0)\")\n  }\n  //Compute number of matching orders\n  matched = 0;\nmatched_loop:\n  while(matched < dimension) {\n    for(j=1; j<nargs; ++j) {\n      if(orders[j][matched] !== orders[0][matched]) {\n        break matched_loop;\n      }\n    }\n    ++matched;\n  }\n  //Generate code\n  code.push(procedure.pre)\n  if(matched === dimension) {\n    code.push(innerFill(order, procedure))\n  } else {\n    code.push(outerFill(matched, order, procedure))\n  }\n  code.push(procedure.post)\n  arglist.push(code.join(\"\\n\"))\n  //Return result\n  var result = Function.apply(null, arglist)\n  if(procedure.printCode) {\n    console.log(\"For order:\", orders, \"Generated code: \\n\", result+\"\")\n  }\n  return result\n}\n\nmodule.exports = generate\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-ops/~/cwise/lib/generate.js\n ** module id = 19\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar ops = require(\"ndarray-ops\")\nvar cwise = require(\"cwise\")\nvar ndarray = require(\"ndarray\")\nvar fftm = require(\"./lib/fft-matrix.js\")\nvar pool = require(\"typedarray-pool\")\n\nfunction ndfft(dir, x, y) {\n  var shape = x.shape\n    , d = shape.length\n    , size = 1\n    , stride = new Array(d)\n    , pad = 0\n    , i, j\n  for(i=d-1; i>=0; --i) {\n    stride[i] = size\n    size *= shape[i]\n    pad = Math.max(pad, fftm.scratchMemory(shape[i]))\n    if(x.shape[i] !== y.shape[i]) {\n      throw new Error(\"Shape mismatch, real and imaginary arrays must have same size\")\n    }\n  }\n  var buffer = pool.malloc(4 * size + pad, \"double\")\n  var x1 = ndarray(buffer, shape.slice(0), stride, 0)\n    , y1 = ndarray(buffer, shape.slice(0), stride.slice(0), size)\n    , x2 = ndarray(buffer, shape.slice(0), stride.slice(0), 2*size)\n    , y2 = ndarray(buffer, shape.slice(0), stride.slice(0), 3*size)\n    , tmp, n, s1, s2\n    , scratch_ptr = 4 * size\n  \n  //Copy into x1/y1\n  ops.assign(x1, x)\n  ops.assign(y1, y)\n  \n  for(i=d-1; i>=0; --i) {\n    fftm(dir, size/shape[i], shape[i], buffer, x1.offset, y1.offset, scratch_ptr)\n    if(i === 0) {\n      break\n    }\n    \n    //Compute new stride for x2/y2\n    n = 1\n    s1 = x2.stride\n    s2 = y2.stride\n    for(j=i-1; j<d; ++j) {\n      s2[j] = s1[j] = n\n      n *= shape[j]\n    }\n    for(j=i-2; j>=0; --j) {\n      s2[j] = s1[j] = n\n      n *= shape[j]\n    }\n    \n    //Transpose\n    ops.assign(x2, x1)\n    ops.assign(y2, y1)\n    \n    //Swap buffers\n    tmp = x1\n    x1 = x2\n    x2 = tmp\n    tmp = y1\n    y1 = y2\n    y2 = tmp\n  }\n  \n  //Copy result back into x\n  ops.assign(x, x1)\n  ops.assign(y, y1)\n  \n  pool.free(buffer)\n}\n\nmodule.exports = ndfft\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/fft.js\n ** module id = 20\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar Parser = require(\"./lib/parser.js\")\n  , createShim = require(\"./lib/shim.js\")\n\nvar REQUIRED_FIELDS = [ \"args\", \"body\" ]\nvar OPTIONAL_FIELDS = [ \"pre\", \"post\", \"printCode\" ]\n\nfunction CompiledProcedure() {\n  this.numArgs = 0\n  this.numArrayArgs = 0\n  this.numScalarArgs = 0\n  this.hasIndex = false\n  this.hasShape = false\n  this.hasReturn = false\n  this.pre = \"\"\n  this.body = \"\"\n  this.post = \"\"\n  this.unroll = 1\n  this.printCode = false\n}\n\nfunction compile(user_args) {\n  for(var id in user_args) {\n    if(REQUIRED_FIELDS.indexOf(id) < 0 &&\n       OPTIONAL_FIELDS.indexOf(id) < 0) {\n      throw new Error(\"Unknown argument '\"+id+\"' passed to expression compiler\")\n    }\n  }\n  for(var i=0; i<REQUIRED_FIELDS.length; ++i) {\n    if(!user_args[REQUIRED_FIELDS[i]]) {\n      throw new Error(\"Missing argument: \" + REQUIRED_FIELDS[i])\n    }\n  }\n  //Parse arguments\n  var proc = new CompiledProcedure()\n  var proc_args = user_args.args.slice(0)\n  var shim_args = []\n  for(var i=0; i<proc_args.length; ++i) {\n    switch(proc_args[i]) {\n      case \"array\":\n        shim_args.push(\"array\" + proc.numArrayArgs)\n        proc_args[i] += (proc.numArrayArgs++)\n      break\n      case \"scalar\":\n        shim_args.push(\"scalar\" + proc.numScalarArgs)\n        proc_args[i] += (proc.numScalarArgs++)\n      break\n      case \"index\":\n        proc.hasIndex = true\n      break\n      case \"shape\":\n        proc.hasShape = true\n      break\n      default:\n        throw new Error(\"Unknown argument types\")\n    }\n  }\n  if(proc.numArrayArgs <= 0) {\n    throw new Error(\"No array arguments specified\")\n  }\n  \n  //Parse blocks\n  var parser = new Parser(proc_args)\n    , pre = user_args.pre || null\n    , body = user_args.body\n    , post = user_args.post || null\n  parser.preprocess(pre)\n  parser.preprocess(body)\n  parser.preprocess(post)\n  proc.pre  = parser.preBlock() + \"\\n\" + parser.process(pre)\n  proc.body = parser.process(body)\n  proc.post = parser.process(post) + \"\\n\" + parser.postBlock()\n  proc.hasReturn = parser.hasReturn\n  \n  //Parse options\n  proc.printCode = user_args.printCode || false\n  \n  //Assemble shim\n  return createShim(shim_args, proc)\n}\n\nmodule.exports = compile\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/index.js\n ** module id = 21\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar falafel = require(\"falafel\")\n\nfunction isGlobal(identifier) {\n  if(typeof(window) !== \"undefined\") {\n    return identifier in window\n  } else if(typeof(GLOBAL) !== \"undefined\") {\n    return identifier in GLOBAL\n  } else {\n    return false\n  }\n}\n\nfunction getArgs(src) {\n  var args = []\n  falafel(src, function(node) {\n    var i\n    if(node.type === \"FunctionExpression\" &&\n       node.parent.parent.parent.type === \"Program\") {\n      args = new Array(node.params.length)\n      for(i=0; i<node.params.length; ++i) {\n        args[i] = node.params[i].name\n      }\n    }\n  })\n  return args\n}\n\nfunction Parser(args) {\n  this.args = args\n  this.this_vars = []\n  this.computed_this = false\n  this.prefix_count = 0\n  this.hasReturn = false\n}\n\n//Preprocessing pass is needed to explode the \"this\" object\nParser.prototype.preprocess = function(func) {\n  if(!func || this.computed_this) {\n    return\n  }\n  var src = \"(\" + func + \")()\"\n    , this_vars = this.this_vars\n    , computed_this = this.computed_this\n  falafel(src, function(node) {\n    var n\n    if(node.type === \"ThisExpression\") {\n      if(node.parent.type === \"MemberExpression\" && !node.parent.computed) {\n        n = node.parent.property.name\n        if(this_vars.indexOf(n) < 0) {\n          this_vars.push(n)\n        }\n      } else {\n        computed_this = true\n      }\n    }\n  })\n  if(computed_this) {\n    this.this_vars = []\n  }\n  this.computed_this = computed_this\n}\n\nParser.prototype.process = function(func) {\n  if(!func) {\n    return \"\"\n  }\n  var label = this.prefix_count++\n    , src = \"(\" + func + \")()\"\n    , block_args = getArgs(src)\n    , proc_args = this.args\n    , result = \"\"\n    , inline_prefix = \"inline\" + label + \"_\"\n    , hasReturn = this.hasReturn\n  falafel(src, function(node) {\n    var n, i, j\n    if(node.type === \"FunctionExpression\" &&\n       node.parent.parent.parent.type === \"Program\") {\n      result = node.body.source()\n    } else if(node.type === \"Identifier\") {\n      if(node.parent.type === \"MemberExpression\") {\n        if((node.parent.property === node && !node.parent.computed) ||\n           node.parent.object.type === \"ThisExpression\") {\n          return\n        }\n      }\n      n = node.name\n      i = block_args.indexOf(n)\n      if(i >= 0) {\n        if(i < proc_args.length) {\n          if(proc_args[i].indexOf(\"array\") === 0) {\n            j = parseInt(proc_args[i].substr(5))\n            node.update(\"arr\"+j+\"[ptr\"+j+\"]\")\n          } else if(proc_args[i] === \"shape\") {\n            node.update(\"inline_shape\")\n          } else {\n            node.update(proc_args[i])\n          }\n        } else {\n          node.update(inline_prefix + node.source())\n        }\n      } else if(isGlobal(n)) {\n        return\n      } else {\n        node.update(inline_prefix + node.source())\n      }\n    } else if(node.type === \"MemberExpression\") {\n      if(node.object.type === \"ThisExpression\") {\n        node.update(\"this_\" + node.property.source().trimLeft())\n      }\n    } else if(node.type === \"ThisExpression\") {\n      if(node.parent.type !== \"MemberExpression\") {\n        node.update(\"this_\")\n      }\n    } else if(node.type === \"ReturnStatement\") {\n      hasReturn = true\n    }\n  })\n  this.hasReturn = hasReturn\n  var prefix = \"\"\n  for(var i=this.args.length; i<block_args.length; ++i) {\n    prefix += \"var \" + block_args[i] + \"\\n\"\n  }\n  return prefix + result\n}\n\nParser.prototype.preBlock = function() {\n  if(this.computed_this) {\n    return \"var this_={}\"\n  } else if(this.this_vars.length > 0) {\n    return \"var this_\" + this.this_vars.join(\",this_\")\n  } else {\n    return \"\"\n  }\n}\n\nParser.prototype.postBlock = function() {\n  return \"\"\n}\n\nmodule.exports = Parser\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/lib/parser.js\n ** module id = 22\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar parse = require('esprima').parse;\nvar objectKeys = Object.keys || function (obj) {\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    return keys;\n};\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn);\n    for (var i = 0; i < xs.length; i++) {\n        fn.call(xs, xs[i], i, xs);\n    }\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nmodule.exports = function (src, opts, fn) {\n    if (typeof opts === 'function') {\n        fn = opts;\n        opts = {};\n    }\n    if (typeof src === 'object') {\n        opts = src;\n        src = opts.source;\n        delete opts.source;\n    }\n    src = src === undefined ? opts.source : src;\n    opts.range = true;\n    if (typeof src !== 'string') src = String(src);\n    \n    var ast = parse(src, opts);\n    \n    var result = {\n        chunks : src.split(''),\n        toString : function () { return result.chunks.join('') },\n        inspect : function () { return result.toString() }\n    };\n    var index = 0;\n    \n    (function walk (node, parent) {\n        insertHelpers(node, parent, result.chunks);\n        \n        forEach(objectKeys(node), function (key) {\n            if (key === 'parent') return;\n            \n            var child = node[key];\n            if (isArray(child)) {\n                forEach(child, function (c) {\n                    if (c && typeof c.type === 'string') {\n                        walk(c, node);\n                    }\n                });\n            }\n            else if (child && typeof child.type === 'string') {\n                insertHelpers(child, node, result.chunks);\n                walk(child, node);\n            }\n        });\n        fn(node);\n    })(ast, undefined);\n    \n    return result;\n};\n \nfunction insertHelpers (node, parent, chunks) {\n    if (!node.range) return;\n    \n    node.parent = parent;\n    \n    node.source = function () {\n        return chunks.slice(\n            node.range[0], node.range[1]\n        ).join('');\n    };\n    \n    if (node.update && typeof node.update === 'object') {\n        var prev = node.update;\n        forEach(objectKeys(prev), function (key) {\n            update[key] = prev[key];\n        });\n        node.update = update;\n    }\n    else {\n        node.update = update;\n    }\n    \n    function update (s) {\n        chunks[node.range[0]] = s;\n        for (var i = node.range[0] + 1; i < node.range[1]; i++) {\n            chunks[i] = '';\n        }\n    };\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/~/falafel/index.js\n ** module id = 23\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/*\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, createLiteral: true, generateStatement: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        buffer,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function sliceSource(from, to) {\n        return source.slice(from, to);\n    }\n\n    if (typeof 'esprima'[0] === 'undefined') {\n        sliceSource = function sliceArraySource(from, to) {\n            return source.slice(from, to).join('');\n        };\n    }\n\n    function isDecimalDigit(ch) {\n        return '0123456789'.indexOf(ch) >= 0;\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === ' ') || (ch === '\\u0009') || (ch === '\\u000B') ||\n            (ch === '\\u000C') || (ch === '\\u00A0') ||\n            (ch.charCodeAt(0) >= 0x1680 &&\n             '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === '\\n' || ch === '\\r' || ch === '\\u2028' || ch === '\\u2029');\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch >= '0') && (ch <= '9')) ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n\n        // Future reserved words.\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n\n        // Strict Mode reserved words.\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        var keyword = false;\n        switch (id.length) {\n        case 2:\n            keyword = (id === 'if') || (id === 'in') || (id === 'do');\n            break;\n        case 3:\n            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');\n            break;\n        case 4:\n            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');\n            break;\n        case 5:\n            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');\n            break;\n        case 6:\n            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');\n            break;\n        case 7:\n            keyword = (id === 'default') || (id === 'finally');\n            break;\n        case 8:\n            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');\n            break;\n        case 10:\n            keyword = (id === 'instanceof');\n            break;\n        }\n\n        if (keyword) {\n            return true;\n        }\n\n        switch (id) {\n        // Future reserved words.\n        // 'const' is specialized as Keyword in V8.\n        case 'const':\n            return true;\n\n        // For compatiblity to SpiderMonkey and ES.next\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        return isFutureReservedWord(id);\n    }\n\n    // 7.4 Comments\n\n    function skipComment() {\n        var ch, blockComment, lineComment;\n\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    lineComment = false;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            ++index;\n                            blockComment = false;\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    index += 2;\n                    lineComment = true;\n                } else if (ch === '*') {\n                    index += 2;\n                    blockComment = true;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanIdentifier() {\n        var ch, start, id, restore;\n\n        ch = source[index];\n        if (!isIdentifierStart(ch)) {\n            return;\n        }\n\n        start = index;\n        if (ch === '\\\\') {\n            ++index;\n            if (source[index] !== 'u') {\n                return;\n            }\n            ++index;\n            restore = index;\n            ch = scanHexEscape('u');\n            if (ch) {\n                if (ch === '\\\\' || !isIdentifierStart(ch)) {\n                    return;\n                }\n                id = ch;\n            } else {\n                index = restore;\n                id = 'u';\n            }\n        } else {\n            id = source[index++];\n        }\n\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            if (ch === '\\\\') {\n                ++index;\n                if (source[index] !== 'u') {\n                    return;\n                }\n                ++index;\n                restore = index;\n                ch = scanHexEscape('u');\n                if (ch) {\n                    if (ch === '\\\\' || !isIdentifierPart(ch)) {\n                        return;\n                    }\n                    id += ch;\n                } else {\n                    index = restore;\n                    id += 'u';\n                }\n            } else {\n                id += source[index++];\n            }\n        }\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            return {\n                type: Token.Identifier,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (isKeyword(id)) {\n            return {\n                type: Token.Keyword,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.1 Null Literals\n\n        if (id === 'null') {\n            return {\n                type: Token.NullLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.2 Boolean Literals\n\n        if (id === 'true' || id === 'false') {\n            return {\n                type: Token.BooleanLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        return {\n            type: Token.Identifier,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        // Check for most common single-character punctuators.\n\n        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Dot (.) can also start a floating-point number, hence the need\n        // to check the next character.\n\n        ch2 = source[index + 1];\n        if (ch1 === '.' && !isDecimalDigit(ch2)) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Peek more characters.\n\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '===',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '!==',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 2-character punctuators: <= >= == != ++ -- << >> && ||\n        // += -= *= %= &= |= ^= /=\n\n        if (ch2 === '=') {\n            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            if ('+-<>&|'.indexOf(ch2) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // The remaining 1-character punctuators.\n\n        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isHexDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 16),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                } else if (isOctalDigit(ch)) {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 8),\n                        octal: true,\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                }\n\n                // decimal number starts with '0' such as '09' is illegal.\n                if (isDecimalDigit(ch)) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n\n            ch = source[index];\n            if (isDecimalDigit(ch)) {\n                number += source[index++];\n                while (index < length) {\n                    ch = source[index];\n                    if (!isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += source[index++];\n                }\n            } else {\n                ch = 'character ' + ch;\n                if (index >= length) {\n                    ch = '<end>';\n                }\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (index < length) {\n            ch = source[index];\n            if (isIdentifierStart(ch)) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch)) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch)) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        buffer = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        str += '\\\\u';\n                        for (; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advance() {\n        var ch, token;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        token = scanPunctuator();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        ch = source[index];\n\n        if (ch === '\\'' || ch === '\"') {\n            return scanStringLiteral();\n        }\n\n        if (ch === '.' || isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        token = scanIdentifier();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function lex() {\n        var token;\n\n        if (buffer) {\n            index = buffer.range[1];\n            lineNumber = buffer.lineNumber;\n            lineStart = buffer.lineStart;\n            token = buffer;\n            buffer = null;\n            return token;\n        }\n\n        buffer = null;\n        return advance();\n    }\n\n    function lookahead() {\n        var pos, line, start;\n\n        if (buffer !== null) {\n            return buffer;\n        }\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        buffer = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return buffer;\n    }\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    return args[index] || '';\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        var token = lookahead();\n        return token.type === Token.Punctuator && token.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        var token = lookahead();\n        return token.type === Token.Keyword && token.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var token = lookahead(),\n            op = token.value;\n\n        if (token.type !== Token.Punctuator) {\n            return false;\n        }\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var token, line;\n\n        // Catch the very common case first.\n        if (source[index] === ';') {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        token = lookahead();\n        if (token.type !== Token.EOF && !match('}')) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return {\n            type: Syntax.ArrayExpression,\n            elements: elements\n        };\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body;\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: null,\n            params: param,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseObjectPropertyKey() {\n        var token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, param;\n\n        token = lookahead();\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                return {\n                    type: Syntax.Property,\n                    key: key,\n                    value: parsePropertyFunction([]),\n                    kind: 'get'\n                };\n            } else if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead();\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction([]),\n                        kind: 'set'\n                    };\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction(param, token),\n                        kind: 'set'\n                    };\n                }\n            } else {\n                expect(':');\n                return {\n                    type: Syntax.Property,\n                    key: id,\n                    value: parseAssignmentExpression(),\n                    kind: 'init'\n                };\n            }\n        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: parseAssignmentExpression(),\n                kind: 'init'\n            };\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n            if (Object.prototype.hasOwnProperty.call(map, name)) {\n                if (map[name] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[name] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[name] |= kind;\n            } else {\n                map[name] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return {\n            type: Syntax.ObjectExpression,\n            properties: properties\n        };\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var token = lookahead(),\n            type = token.type;\n\n        if (type === Token.Identifier) {\n            return {\n                type: Syntax.Identifier,\n                name: lex().value\n            };\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(lex());\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                return {\n                    type: Syntax.ThisExpression\n                };\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            lex();\n            token.value = (token.value === 'true');\n            return createLiteral(token);\n        }\n\n        if (type === Token.NullLiteral) {\n            lex();\n            token.value = null;\n            return createLiteral(token);\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            return createLiteral(scanRegExp());\n        }\n\n        return throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var expr;\n\n        expectKeyword('new');\n\n        expr = {\n            type: Syntax.NewExpression,\n            callee: parseLeftHandSideExpression(),\n            'arguments': []\n        };\n\n        if (match('(')) {\n            expr['arguments'] = parseArguments();\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n\n    function parseLeftHandSideExpression() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr = parseLeftHandSideExpressionAllowCall(), token;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: lex().value,\n                argument: expr,\n                prefix: false\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: token.value,\n                argument: expr,\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    // 11.5 Multiplicative Operators\n\n    function parseMultiplicativeExpression() {\n        var expr = parseUnaryExpression();\n\n        while (match('*') || match('/') || match('%')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseUnaryExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.6 Additive Operators\n\n    function parseAdditiveExpression() {\n        var expr = parseMultiplicativeExpression();\n\n        while (match('+') || match('-')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseMultiplicativeExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.7 Bitwise Shift Operators\n\n    function parseShiftExpression() {\n        var expr = parseAdditiveExpression();\n\n        while (match('<<') || match('>>') || match('>>>')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAdditiveExpression()\n            };\n        }\n\n        return expr;\n    }\n    // 11.8 Relational Operators\n\n    function parseRelationalExpression() {\n        var expr, previousAllowIn;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        expr = parseShiftExpression();\n\n        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseShiftExpression()\n            };\n        }\n\n        state.allowIn = previousAllowIn;\n        return expr;\n    }\n\n    // 11.9 Equality Operators\n\n    function parseEqualityExpression() {\n        var expr = parseRelationalExpression();\n\n        while (match('==') || match('!=') || match('===') || match('!==')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseRelationalExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.10 Binary Bitwise Operators\n\n    function parseBitwiseANDExpression() {\n        var expr = parseEqualityExpression();\n\n        while (match('&')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '&',\n                left: expr,\n                right: parseEqualityExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseXORExpression() {\n        var expr = parseBitwiseANDExpression();\n\n        while (match('^')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '^',\n                left: expr,\n                right: parseBitwiseANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseORExpression() {\n        var expr = parseBitwiseXORExpression();\n\n        while (match('|')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '|',\n                left: expr,\n                right: parseBitwiseXORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.11 Binary Logical Operators\n\n    function parseLogicalANDExpression() {\n        var expr = parseBitwiseORExpression();\n\n        while (match('&&')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '&&',\n                left: expr,\n                right: parseBitwiseORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseLogicalORExpression() {\n        var expr = parseLogicalANDExpression();\n\n        while (match('||')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '||',\n                left: expr,\n                right: parseLogicalANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent;\n\n        expr = parseLogicalORExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n\n            expr = {\n                type: Syntax.ConditionalExpression,\n                test: expr,\n                consequent: consequent,\n                alternate: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr;\n\n        token = lookahead();\n        expr = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            expr = {\n                type: Syntax.AssignmentExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = {\n                type: Syntax.SequenceExpression,\n                expressions: [ expr ]\n            };\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n\n        }\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block;\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return {\n            type: Syntax.BlockStatement,\n            body: block\n        };\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id = parseVariableIdentifier(),\n            init = null;\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return {\n            type: Syntax.VariableDeclarator,\n            id: id,\n            init: init\n        };\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: 'var'\n        };\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations;\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: kind\n        };\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n\n        return {\n            type: Syntax.EmptyStatement\n        };\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return {\n            type: Syntax.IfStatement,\n            test: test,\n            consequent: consequent,\n            alternate: alternate\n        };\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return {\n            type: Syntax.DoWhileStatement,\n            body: body,\n            test: test\n        };\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return {\n            type: Syntax.WhileStatement,\n            test: test,\n            body: body\n        };\n    }\n\n    function parseForVariableDeclaration() {\n        var token = lex();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: parseVariableDeclarationList(),\n            kind: token.value\n        };\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        }\n\n        return {\n            type: Syntax.ForInStatement,\n            left: left,\n            right: right,\n            body: body,\n            each: false\n        };\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var token, label = null;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return {\n            type: Syntax.ContinueStatement,\n            label: label\n        };\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var token, label = null;\n\n        expectKeyword('break');\n\n        // Optimize the most common form: 'break;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return {\n            type: Syntax.BreakStatement,\n            label: label\n        };\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var token, argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source[index] === ' ') {\n            if (isIdentifierStart(source[index + 1])) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return {\n                    type: Syntax.ReturnStatement,\n                    argument: argument\n                };\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: null\n            };\n        }\n\n        if (!match(';')) {\n            token = lookahead();\n            if (!match('}') && token.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ReturnStatement,\n            argument: argument\n        };\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return {\n            type: Syntax.WithStatement,\n            object: object,\n            body: body\n        };\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            statement;\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            consequent.push(statement);\n        }\n\n        return {\n            type: Syntax.SwitchCase,\n            test: test,\n            consequent: consequent\n        };\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return {\n            type: Syntax.SwitchStatement,\n            discriminant: discriminant,\n            cases: cases\n        };\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ThrowStatement,\n            argument: argument\n        };\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param;\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead());\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n\n        return {\n            type: Syntax.CatchClause,\n            param: param,\n            body: parseBlock()\n        };\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return {\n            type: Syntax.TryStatement,\n            block: block,\n            guardedHandlers: [],\n            handlers: handlers,\n            finalizer: finalizer\n        };\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.DebuggerStatement\n        };\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var token = lookahead(),\n            expr,\n            labeledBody;\n\n        if (token.type === Token.EOF) {\n            throwUnexpected(token);\n        }\n\n        if (token.type === Token.Punctuator) {\n            switch (token.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[expr.name] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[expr.name];\n\n            return {\n                type: Syntax.LabeledStatement,\n                label: expr,\n                body: labeledBody\n            };\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;\n\n        expect('{');\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return {\n            type: Syntax.BlockStatement,\n            body: sourceElements\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;\n\n        expectKeyword('function');\n        token = lookahead();\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionDeclaration,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead();\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        var token = lookahead();\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(token.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (token.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var program;\n        strict = false;\n        program = {\n            type: Syntax.Program,\n            body: parseSourceElements()\n        };\n        return program;\n    }\n\n    // The following functions are needed only when the option to preserve\n    // the comments is active.\n\n    function addComment(type, value, start, end, loc) {\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (extra.comments.length > 0) {\n            if (extra.comments[extra.comments.length - 1].range[1] > start) {\n                return;\n            }\n        }\n\n        extra.comments.push({\n            type: type,\n            value: value,\n            range: [start, end],\n            loc: loc\n        });\n    }\n\n    function scanComment() {\n        var comment, ch, loc, start, blockComment, lineComment;\n\n        comment = '';\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    lineComment = false;\n                    addComment('Line', comment, start, index - 1, loc);\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                    comment = '';\n                } else if (index >= length) {\n                    lineComment = false;\n                    comment += ch;\n                    loc.end = {\n                        line: lineNumber,\n                        column: length - lineStart\n                    };\n                    addComment('Line', comment, start, length, loc);\n                } else {\n                    comment += ch;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                        comment += '\\r\\n';\n                    } else {\n                        comment += ch;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    comment += ch;\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            comment = comment.substr(0, comment.length - 1);\n                            blockComment = false;\n                            ++index;\n                            loc.end = {\n                                line: lineNumber,\n                                column: index - lineStart\n                            };\n                            addComment('Block', comment, start, index, loc);\n                            comment = '';\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart\n                        }\n                    };\n                    start = index;\n                    index += 2;\n                    lineComment = true;\n                    if (index >= length) {\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        lineComment = false;\n                        addComment('Line', comment, start, index, loc);\n                    }\n                } else if (ch === '*') {\n                    start = index;\n                    index += 2;\n                    blockComment = true;\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart - 2\n                        }\n                    };\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function filterCommentLocation() {\n        var i, entry, comment, comments = [];\n\n        for (i = 0; i < extra.comments.length; ++i) {\n            entry = extra.comments[i];\n            comment = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                comment.range = entry.range;\n            }\n            if (extra.loc) {\n                comment.loc = entry.loc;\n            }\n            comments.push(comment);\n        }\n\n        extra.comments = comments;\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = sliceSource(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        // Pop the previous token, which is likely '/' or '/='\n        if (extra.tokens.length > 0) {\n            token = extra.tokens[extra.tokens.length - 1];\n            if (token.range[0] === pos && token.type === 'Punctuator') {\n                if (token.value === '/' || token.value === '/=') {\n                    extra.tokens.pop();\n                }\n            }\n        }\n\n        extra.tokens.push({\n            type: 'RegularExpression',\n            value: regex.literal,\n            range: [pos, index],\n            loc: loc\n        });\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function createLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value\n        };\n    }\n\n    function createRawLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value,\n            raw: sliceSource(token.range[0], token.range[1])\n        };\n    }\n\n    function createLocationMarker() {\n        var marker = {};\n\n        marker.range = [index, index];\n        marker.loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            },\n            end: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        marker.end = function () {\n            this.range[1] = index;\n            this.loc.end.line = lineNumber;\n            this.loc.end.column = index - lineStart;\n        };\n\n        marker.applyGroup = function (node) {\n            if (extra.range) {\n                node.groupRange = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.groupLoc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        marker.apply = function (node) {\n            if (extra.range) {\n                node.range = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        return marker;\n    }\n\n    function trackGroupExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        marker.end();\n        marker.applyGroup(expr);\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpressionAllowCall() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function filterGroup(node) {\n        var n, i, entry;\n\n        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};\n        for (i in node) {\n            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {\n                entry = node[i];\n                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {\n                    n[i] = entry;\n                } else {\n                    n[i] = filterGroup(entry);\n                }\n            }\n        }\n        return n;\n    }\n\n    function wrapTrackingFunction(range, loc) {\n\n        return function (parseFunction) {\n\n            function isBinary(node) {\n                return node.type === Syntax.LogicalExpression ||\n                    node.type === Syntax.BinaryExpression;\n            }\n\n            function visit(node) {\n                var start, end;\n\n                if (isBinary(node.left)) {\n                    visit(node.left);\n                }\n                if (isBinary(node.right)) {\n                    visit(node.right);\n                }\n\n                if (range) {\n                    if (node.left.groupRange || node.right.groupRange) {\n                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];\n                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];\n                        node.range = [start, end];\n                    } else if (typeof node.range === 'undefined') {\n                        start = node.left.range[0];\n                        end = node.right.range[1];\n                        node.range = [start, end];\n                    }\n                }\n                if (loc) {\n                    if (node.left.groupLoc || node.right.groupLoc) {\n                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;\n                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;\n                        node.loc = {\n                            start: start,\n                            end: end\n                        };\n                    } else if (typeof node.loc === 'undefined') {\n                        node.loc = {\n                            start: node.left.loc.start,\n                            end: node.right.loc.end\n                        };\n                    }\n                }\n            }\n\n            return function () {\n                var marker, node;\n\n                skipComment();\n\n                marker = createLocationMarker();\n                node = parseFunction.apply(null, arguments);\n                marker.end();\n\n                if (range && typeof node.range === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (loc && typeof node.loc === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (isBinary(node)) {\n                    visit(node);\n                }\n\n                return node;\n            };\n        };\n    }\n\n    function patch() {\n\n        var wrapTracking;\n\n        if (extra.comments) {\n            extra.skipComment = skipComment;\n            skipComment = scanComment;\n        }\n\n        if (extra.raw) {\n            extra.createLiteral = createLiteral;\n            createLiteral = createRawLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n\n            extra.parseGroupExpression = parseGroupExpression;\n            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;\n            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;\n            parseGroupExpression = trackGroupExpression;\n            parseLeftHandSideExpression = trackLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;\n\n            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);\n\n            extra.parseAdditiveExpression = parseAdditiveExpression;\n            extra.parseAssignmentExpression = parseAssignmentExpression;\n            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;\n            extra.parseBitwiseORExpression = parseBitwiseORExpression;\n            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;\n            extra.parseBlock = parseBlock;\n            extra.parseFunctionSourceElements = parseFunctionSourceElements;\n            extra.parseCatchClause = parseCatchClause;\n            extra.parseComputedMember = parseComputedMember;\n            extra.parseConditionalExpression = parseConditionalExpression;\n            extra.parseConstLetDeclaration = parseConstLetDeclaration;\n            extra.parseEqualityExpression = parseEqualityExpression;\n            extra.parseExpression = parseExpression;\n            extra.parseForVariableDeclaration = parseForVariableDeclaration;\n            extra.parseFunctionDeclaration = parseFunctionDeclaration;\n            extra.parseFunctionExpression = parseFunctionExpression;\n            extra.parseLogicalANDExpression = parseLogicalANDExpression;\n            extra.parseLogicalORExpression = parseLogicalORExpression;\n            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;\n            extra.parseNewExpression = parseNewExpression;\n            extra.parseNonComputedProperty = parseNonComputedProperty;\n            extra.parseObjectProperty = parseObjectProperty;\n            extra.parseObjectPropertyKey = parseObjectPropertyKey;\n            extra.parsePostfixExpression = parsePostfixExpression;\n            extra.parsePrimaryExpression = parsePrimaryExpression;\n            extra.parseProgram = parseProgram;\n            extra.parsePropertyFunction = parsePropertyFunction;\n            extra.parseRelationalExpression = parseRelationalExpression;\n            extra.parseStatement = parseStatement;\n            extra.parseShiftExpression = parseShiftExpression;\n            extra.parseSwitchCase = parseSwitchCase;\n            extra.parseUnaryExpression = parseUnaryExpression;\n            extra.parseVariableDeclaration = parseVariableDeclaration;\n            extra.parseVariableIdentifier = parseVariableIdentifier;\n\n            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);\n            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);\n            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);\n            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);\n            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);\n            parseBlock = wrapTracking(extra.parseBlock);\n            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);\n            parseCatchClause = wrapTracking(extra.parseCatchClause);\n            parseComputedMember = wrapTracking(extra.parseComputedMember);\n            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);\n            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);\n            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);\n            parseExpression = wrapTracking(extra.parseExpression);\n            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);\n            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);\n            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);\n            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);\n            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);\n            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);\n            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);\n            parseNewExpression = wrapTracking(extra.parseNewExpression);\n            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);\n            parseObjectProperty = wrapTracking(extra.parseObjectProperty);\n            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);\n            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);\n            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);\n            parseProgram = wrapTracking(extra.parseProgram);\n            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);\n            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);\n            parseStatement = wrapTracking(extra.parseStatement);\n            parseShiftExpression = wrapTracking(extra.parseShiftExpression);\n            parseSwitchCase = wrapTracking(extra.parseSwitchCase);\n            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);\n            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);\n            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);\n        }\n\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.skipComment === 'function') {\n            skipComment = extra.skipComment;\n        }\n\n        if (extra.raw) {\n            createLiteral = extra.createLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n            parseAdditiveExpression = extra.parseAdditiveExpression;\n            parseAssignmentExpression = extra.parseAssignmentExpression;\n            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;\n            parseBitwiseORExpression = extra.parseBitwiseORExpression;\n            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;\n            parseBlock = extra.parseBlock;\n            parseFunctionSourceElements = extra.parseFunctionSourceElements;\n            parseCatchClause = extra.parseCatchClause;\n            parseComputedMember = extra.parseComputedMember;\n            parseConditionalExpression = extra.parseConditionalExpression;\n            parseConstLetDeclaration = extra.parseConstLetDeclaration;\n            parseEqualityExpression = extra.parseEqualityExpression;\n            parseExpression = extra.parseExpression;\n            parseForVariableDeclaration = extra.parseForVariableDeclaration;\n            parseFunctionDeclaration = extra.parseFunctionDeclaration;\n            parseFunctionExpression = extra.parseFunctionExpression;\n            parseGroupExpression = extra.parseGroupExpression;\n            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;\n            parseLogicalANDExpression = extra.parseLogicalANDExpression;\n            parseLogicalORExpression = extra.parseLogicalORExpression;\n            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;\n            parseNewExpression = extra.parseNewExpression;\n            parseNonComputedProperty = extra.parseNonComputedProperty;\n            parseObjectProperty = extra.parseObjectProperty;\n            parseObjectPropertyKey = extra.parseObjectPropertyKey;\n            parsePrimaryExpression = extra.parsePrimaryExpression;\n            parsePostfixExpression = extra.parsePostfixExpression;\n            parseProgram = extra.parseProgram;\n            parsePropertyFunction = extra.parsePropertyFunction;\n            parseRelationalExpression = extra.parseRelationalExpression;\n            parseStatement = extra.parseStatement;\n            parseShiftExpression = extra.parseShiftExpression;\n            parseSwitchCase = extra.parseSwitchCase;\n            parseUnaryExpression = extra.parseUnaryExpression;\n            parseVariableDeclaration = extra.parseVariableDeclaration;\n            parseVariableIdentifier = extra.parseVariableIdentifier;\n        }\n\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    function stringToArray(str) {\n        var length = str.length,\n            result = [],\n            i;\n        for (i = 0; i < length; ++i) {\n            result[i] = str.charAt(i);\n        }\n        return result;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        buffer = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.raw = (typeof options.raw === 'boolean') && options.raw;\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n\n                // Force accessing the characters via an array.\n                if (typeof source[0] === 'undefined') {\n                    source = stringToArray(code);\n                }\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                filterCommentLocation();\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n            if (extra.range || extra.loc) {\n                program.body = filterGroup(program.body);\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with package.json.\n    exports.version = '1.0.4';\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/~/falafel/~/esprima/esprima.js\n ** module id = 24\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar generate = require(\"./generate.js\")\n\n//Reuse stack across all shims\nvar STACK = new Int32Array(1024)\n\nfunction Shim(procedure) {\n  this.memoized = {}\n  this.procedure = procedure\n}\n\nShim.prototype.checkShape = function(a, b) {\n  if(a.length !== b.length) {\n    throw new Error(\"Shape mismatch\")\n  }\n  for(var i=a.length-1; i>=0; --i) {\n    if(a[i] !== b[i]) {\n      throw new Error(\"Shape mismatch\")\n    }\n  }\n}\n\nShim.prototype.getStack = function(size) {\n  if(size < STACK.length) {\n    return STACK\n  }\n  STACK = new Int32Array(size)\n  return STACK\n}\n\nfunction compare1st(a,b) { return a[0] - b[0]; }\n\nShim.prototype.getOrder = function(stride) {\n  var zipped = new Array(stride.length)\n  for(var i=0; i<stride.length; ++i) {\n    zipped[i] = [Math.abs(stride[i]), i]\n  }\n  zipped.sort(compare1st)\n  var unzipped = new Array(stride.length)\n  for(var i=0; i<stride.length; ++i) {\n    unzipped[i] = zipped[i][1]\n  }\n  return unzipped\n}\n\nShim.prototype.getProc = function(orders) {\n  var proc_name = orders.join(\"|\")\n    , proc = this.memoized[proc_name]\n  if(!proc) {\n    proc = generate(orders, this.procedure)\n    this.memoized[proc_name] = proc\n  }\n  return proc\n}\n\nfunction createShim(shim_args, procedure) {\n  var code = [\"\\\"use strict\\\"\"], i\n  //Check shapes\n  for(i=1; i<procedure.numArrayArgs; ++i) {\n    code.push(\"this.checkShape(array0.shape,array\"+i+\".shape)\")\n  }\n  //Load/lazily generate procedure based on array ordering\n  code.push(\"var proc = this.getProc([\")\n  for(i=0; i<procedure.numArrayArgs; ++i) {\n    code.push((i>0 ? \",\" : \"\") + \"this.getOrder(array\"+i+\".stride)\")\n  }\n  code.push(\"])\")\n  //Call procedure\n  if(procedure.hasReturn) {\n    code.push(\"return proc(\")\n  } else {\n    code.push(\"proc(\")\n  }\n  code.push(\"this.getStack(\" + procedure.numArrayArgs + \"*(array0.shape.length*32)), array0.shape.slice(0)\")\n  //Bind array arguments\n  for(i=0; i<procedure.numArrayArgs; ++i) {\n    code.push(\",array\" + i + \".data\")\n    code.push(\",array\" + i + \".offset\")\n    code.push(\",array\" + i + \".stride\")\n  }\n  //Bind scalar arguments\n  for(var i=0; i<procedure.numScalarArgs; ++i) {\n    code.push(\",scalar\"+i)\n  }\n  code.push(\")\")\n  if(!procedure.hasReturn) {\n    code.push(\"return array0\")\n  }\n  //Create the shim\n  shim_args.push(code.join(\"\\n\"))\n  var result = Function.apply(null, shim_args)\n  if(procedure.printCode) {\n    console.log(\"Generated shim:\", result + \"\")\n  }\n  return result.bind(new Shim(procedure))\n}\n\nmodule.exports = createShim\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/lib/shim.js\n ** module id = 25\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar RECURSION_LIMIT = 32\n\nfunction innerFill(order, procedure) {\n  var dimension = order.length\n    , nargs = procedure.numArrayArgs\n    , has_index = procedure.hasIndex\n    , code = []\n    , idx=0, pidx=0, i, j\n  for(i=0; i<dimension; ++i) {\n    code.push(\"var i\"+i+\"=0;\")\n  }\n  //Compute scan deltas\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx\n      idx = order[i]\n      if(i === 0) {\n        code.push(\"var d\"+j+\"s\"+i+\"=stride\"+j+\"[\"+idx+\"]|0;\")\n      } else {\n        code.push(\"var d\"+j+\"s\"+i+\"=(stride\"+j+\"[\"+idx+\"]-shape[\"+pidx+\"]*stride\"+j+\"[\"+pidx+\"])|0;\")\n      }\n    }\n  }\n  //Outer scan loop\n  for(i=dimension-1; i>=0; --i) {\n    idx = order[i]\n    code.push(\"for(i\"+i+\"=shape[\"+idx+\"]|0;--i\"+i+\">=0;){\")\n  }\n  //Push body of inner loop\n  code.push(procedure.body)\n  //Advance scan pointers\n  for(i=0; i<dimension; ++i) {\n    pidx = idx\n    idx = order[i]\n    for(j=0; j<nargs; ++j) {\n      code.push(\"ptr\"+j+\"+=d\"+j+\"s\"+i)\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push(\"index[\"+pidx+\"]-=shape[\"+pidx+\"]\")\n      }\n      code.push(\"++index[\"+idx+\"]\")\n    }\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\nfunction outerFill(matched, order, procedure) {\n  var dimension = order.length\n    , nargs = procedure.numArrayArgs\n    , has_index = procedure.hasIndex\n    , code = []\n    , static_args = dimension\n    , index_start = nargs + static_args\n    , frame_size = index_start + (has_index ? dimension : 0)\n    , i\n  \n  //Initiaize variables\n  code.push(\"var i=0,l=0,v=0,d=0,sp=0\")\n  \n  //Begin recursion\n  code.push(\"while(true){\")\n    \n    //Walk over runs to get bounds\n    code.push(\"l=\"+RECURSION_LIMIT)\n    code.push(\"v=\"+RECURSION_LIMIT)\n    code.push(\"d=\"+matched)\n  \n    for(i=matched; i<dimension; ++i) {\n      code.push(\"if(shape[\"+i+\"]>l){\")\n        code.push(\"v=l|0\")\n        code.push(\"l=shape[\"+i+\"]|0\")\n        code.push(\"d=\"+i+\"|0\")\n      code.push(\"}else if(shape[\"+i+\"]>v){\")\n        code.push(\"v=shape[\"+i+\"]|0\")\n      code.push(\"}\")\n    }\n  \n    code.push(\"if(l<=\"+RECURSION_LIMIT+\"){\")\n      code.push(innerFill(order, procedure))\n    code.push(\"} else {\")\n  \n      //Round v to previous power of 2\n      code.push(\"v=(v>>>1)-1\")\n      code.push(\"for(i=1;i<=16;i<<=1){v|=v>>>i}\")\n      code.push(\"++v\")\n      code.push(\"if(v<\"+RECURSION_LIMIT+\") v=\"+RECURSION_LIMIT)\n  \n      //Set shape\n      code.push(\"i=shape[d]\")\n      code.push(\"shape[d]=v\")\n  \n      //Fill across row\n      code.push(\"for(;i>=v;i-=v){\")\n        for(i=0; i<dimension; ++i) {\n          code.push(\"STACK[sp+\"+i+\"]=shape[\"+i+\"]\")\n        }\n        for(i=0; i<nargs; ++i) {\n          code.push(\"STACK[sp+\"+(i+static_args)+\"]=ptr\"+i+\"|0\")\n        }\n        if(has_index) {\n          for(i=0; i<dimension; ++i) {\n            code.push(\"STACK[sp+\"+(i+index_start)+\"]=index[\"+i+\"]\")\n          }\n          code.push(\"index[d]+=v\")\n        }\n        for(i=0; i<nargs; ++i) {\n          code.push(\"ptr\"+i+\"+=(v*stride\"+i+\"[d])|0\")\n        }\n        code.push(\"sp+=\"+frame_size)\n      code.push(\"}\")\n  \n      //Handle edge case\n      code.push(\"if(i>0){\")\n        code.push(\"shape[d]=i\")\n        for(i=0; i<dimension; ++i) {\n          code.push(\"STACK[sp+\"+i+\"]=shape[\"+i+\"]\")\n        }\n        for(i=0; i<nargs; ++i) {\n          code.push(\"STACK[sp+\"+(i+static_args)+\"]=ptr\"+i+\"|0\")\n        }\n        if(has_index) {\n          for(i=0; i<dimension; ++i) {\n            code.push(\"STACK[sp+\"+(i+index_start)+\"]=index[\"+i+\"]\")\n          }\n        }\n        code.push(\"sp+=\"+frame_size)\n      code.push(\"}\")\n    code.push(\"}\")\n  \n    //Pop previous state\n    code.push(\"if(sp<=0){\")\n      code.push(\"break\")\n    code.push(\"}\")\n    code.push(\"sp-=\"+frame_size)\n    for(i=0; i<dimension; ++i) {\n      code.push(\"shape[\"+i+\"]=STACK[sp+\"+i+\"]\")\n    }\n    for(i=0; i<nargs; ++i) {\n      code.push(\"ptr\"+i+\"=STACK[sp+\"+(i+static_args)+\"]\")\n    }\n    if(has_index) {\n      for(i=0; i<dimension; ++i) {\n        code.push(\"index[\"+i+\"]=STACK[sp+\"+(i+index_start)+\"]\")\n      }\n    }\n code.push(\"}\")\n return code.join(\"\\n\")\n}\n\nfunction majorOrder(orders) {\n  return orders[0]\n}\n\nfunction generate(orders, procedure) {\n  var order = majorOrder(orders)\n    , dimension = orders[0].length\n    , nargs = procedure.numArrayArgs\n    , code = ['\"use strict\"']\n    , matched, i, j\n    , arglist = [ \"STACK\", \"shape\" ]\n  //Create procedure arguments\n  for(i = 0; i<nargs; ++i) {\n    arglist.push(\"arr\" + i)\n    arglist.push(\"ptr\" + i)\n    arglist.push(\"stride\" + i)\n    code.push(\"ptr\"+i+\"|=0\")\n    for(j = 0; j<dimension; ++j) {\n      code.push(\"stride\"+i+\"[\"+j+\"]|=0\")\n    }\n  }\n  for(i = 0; i<dimension; ++i) {\n    code.push(\"shape[\"+i+\"]|=0\")\n  }\n  for(i = 0; i<procedure.numScalarArgs; ++i) {\n    arglist.push(\"scalar\"+i)\n  }\n  if(procedure.hasIndex) {\n    code.push(\"var index=[\")\n    for(i=0; i<dimension; ++i) {\n      code.push((i > 0) ? \",0\":\"0\")\n    }\n    code.push(\"]\")\n  }\n  if(procedure.hasShape) {\n    code.push(\"var inline_shape=shape.slice(0)\")\n  }\n  //Compute number of matching orders\n  matched = 0;\nmatched_loop:\n  while(matched < dimension) {\n    for(j=1; j<nargs; ++j) {\n      if(orders[j][matched] !== orders[0][matched]) {\n        break matched_loop;\n      }\n    }\n    ++matched;\n  }\n  //Generate code\n  code.push(procedure.pre)\n  if(matched === dimension) {\n    code.push(innerFill(order, procedure))\n  } else {\n    code.push(outerFill(matched, order, procedure))\n  }\n  code.push(procedure.post)\n  arglist.push(code.join(\"\\n\"))\n  //Return result\n  var result = Function.apply(null, arglist)\n  if(procedure.printCode) {\n    console.log(\"For order:\", orders, \"Generated code: \\n\", result+\"\")\n  }\n  return result\n}\n\nmodule.exports = generate\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/cwise/lib/generate.js\n ** module id = 26\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar bits = require(\"bit-twiddle\")\n\nfunction fft(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr) {\n  dir |= 0\n  nrows |= 0\n  ncols |= 0\n  x_ptr |= 0\n  y_ptr |= 0\n  if(bits.isPow2(ncols)) {\n    fftRadix2(dir, nrows, ncols, buffer, x_ptr, y_ptr)\n  } else {\n    fftBluestein(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr)\n  }\n}\nmodule.exports = fft\n\nfunction scratchMemory(n) {\n  if(bits.isPow2(n)) {\n    return 0\n  }\n  return 2 * n + 4 * bits.nextPow2(2*n + 1)\n}\nmodule.exports.scratchMemory = scratchMemory\n\n\n//Radix 2 FFT Adapted from Paul Bourke's C Implementation\nfunction fftRadix2(dir, nrows, ncols, buffer, x_ptr, y_ptr) {\n  dir |= 0\n  nrows |= 0\n  ncols |= 0\n  x_ptr |= 0\n  y_ptr |= 0\n  var nn,i,i1,j,k,i2,l,l1,l2\n  var c1,c2,t,t1,t2,u1,u2,z,row,a,b,c,d,k1,k2,k3\n  \n  // Calculate the number of points\n  nn = ncols\n  m = bits.log2(nn)\n  \n  for(row=0; row<nrows; ++row) {  \n    // Do the bit reversal\n    i2 = nn >> 1;\n    j = 0;\n    for(i=0;i<nn-1;i++) {\n      if(i < j) {\n        t = buffer[x_ptr+i]\n        buffer[x_ptr+i] = buffer[x_ptr+j]\n        buffer[x_ptr+j] = t\n        t = buffer[y_ptr+i]\n        buffer[y_ptr+i] = buffer[y_ptr+j]\n        buffer[y_ptr+j] = t\n      }\n      k = i2\n      while(k <= j) {\n        j -= k\n        k >>= 1\n      }\n      j += k\n    }\n    \n    // Compute the FFT\n    c1 = -1.0\n    c2 = 0.0\n    l2 = 1\n    for(l=0;l<m;l++) {\n      l1 = l2\n      l2 <<= 1\n      u1 = 1.0\n      u2 = 0.0\n      for(j=0;j<l1;j++) {\n        for(i=j;i<nn;i+=l2) {\n          i1 = i + l1\n          a = buffer[x_ptr+i1]\n          b = buffer[y_ptr+i1]\n          c = buffer[x_ptr+i]\n          d = buffer[y_ptr+i]\n          k1 = u1 * (a + b)\n          k2 = a * (u2 - u1)\n          k3 = b * (u1 + u2)\n          t1 = k1 - k3\n          t2 = k1 + k2\n          buffer[x_ptr+i1] = c - t1\n          buffer[y_ptr+i1] = d - t2\n          buffer[x_ptr+i] += t1\n          buffer[y_ptr+i] += t2\n        }\n        k1 = c1 * (u1 + u2)\n        k2 = u1 * (c2 - c1)\n        k3 = u2 * (c1 + c2)\n        u1 = k1 - k3\n        u2 = k1 + k2\n      }\n      c2 = Math.sqrt((1.0 - c1) / 2.0)\n      if(dir < 0) {\n        c2 = -c2\n      }\n      c1 = Math.sqrt((1.0 + c1) / 2.0)\n    }\n    \n    // Scaling for inverse transform\n    if(dir < 0) {\n      var scale_f = 1.0 / nn\n      for(i=0;i<nn;i++) {\n        buffer[x_ptr+i] *= scale_f\n        buffer[y_ptr+i] *= scale_f\n      }\n    }\n    \n    // Advance pointers\n    x_ptr += ncols\n    y_ptr += ncols\n  }\n}\n\n// Use Bluestein algorithm for npot FFTs\n// Scratch memory required:  2 * ncols + 4 * bits.nextPow2(2*ncols + 1)\nfunction fftBluestein(dir, nrows, ncols, buffer, x_ptr, y_ptr, scratch_ptr) {\n  dir |= 0\n  nrows |= 0\n  ncols |= 0\n  x_ptr |= 0\n  y_ptr |= 0\n  scratch_ptr |= 0\n\n  // Initialize tables\n  var m = bits.nextPow2(2 * ncols + 1)\n    , cos_ptr = scratch_ptr\n    , sin_ptr = cos_ptr + ncols\n    , xs_ptr  = sin_ptr + ncols\n    , ys_ptr  = xs_ptr  + m\n    , cft_ptr = ys_ptr  + m\n    , sft_ptr = cft_ptr + m\n    , w = -dir * Math.PI / ncols\n    , row, a, b, c, d, k1, k2, k3\n    , i\n  for(i=0; i<ncols; ++i) {\n    a = w * ((i * i) % (ncols * 2))\n    c = Math.cos(a)\n    d = Math.sin(a)\n    buffer[cft_ptr+(m-i)] = buffer[cft_ptr+i] = buffer[cos_ptr+i] = c\n    buffer[sft_ptr+(m-i)] = buffer[sft_ptr+i] = buffer[sin_ptr+i] = d\n  }\n  for(i=ncols; i<=m-ncols; ++i) {\n    buffer[cft_ptr+i] = 0.0\n  }\n  for(i=ncols; i<=m-ncols; ++i) {\n    buffer[sft_ptr+i] = 0.0\n  }\n\n  fftRadix2(1, 1, m, buffer, cft_ptr, sft_ptr)\n  \n  //Compute scale factor\n  if(dir < 0) {\n    w = 1.0 / ncols\n  } else {\n    w = 1.0\n  }\n  \n  //Handle direction\n  for(row=0; row<nrows; ++row) {\n  \n    // Copy row into scratch memory, multiply weights\n    for(i=0; i<ncols; ++i) {\n      a = buffer[x_ptr+i]\n      b = buffer[y_ptr+i]\n      c = buffer[cos_ptr+i]\n      d = -buffer[sin_ptr+i]\n      k1 = c * (a + b)\n      k2 = a * (d - c)\n      k3 = b * (c + d)\n      buffer[xs_ptr+i] = k1 - k3\n      buffer[ys_ptr+i] = k1 + k2\n    }\n    //Zero out the rest\n    for(i=ncols; i<m; ++i) {\n      buffer[xs_ptr+i] = 0.0\n    }\n    for(i=ncols; i<m; ++i) {\n      buffer[ys_ptr+i] = 0.0\n    }\n    \n    // FFT buffer\n    fftRadix2(1, 1, m, buffer, xs_ptr, ys_ptr)\n    \n    // Apply multiplier\n    for(i=0; i<m; ++i) {\n      a = buffer[xs_ptr+i]\n      b = buffer[ys_ptr+i]\n      c = buffer[cft_ptr+i]\n      d = buffer[sft_ptr+i]\n      k1 = c * (a + b)\n      k2 = a * (d - c)\n      k3 = b * (c + d)\n      buffer[xs_ptr+i] = k1 - k3\n      buffer[ys_ptr+i] = k1 + k2\n    }\n    \n    // Inverse FFT buffer\n    fftRadix2(-1, 1, m, buffer, xs_ptr, ys_ptr)\n    \n    // Copy result back into x/y\n    for(i=0; i<ncols; ++i) {\n      a = buffer[xs_ptr+i]\n      b = buffer[ys_ptr+i]\n      c = buffer[cos_ptr+i]\n      d = -buffer[sin_ptr+i]\n      k1 = c * (a + b)\n      k2 = a * (d - c)\n      k3 = b * (c + d)\n      buffer[x_ptr+i] = w * (k1 - k3)\n      buffer[y_ptr+i] = w * (k1 + k2)\n    }\n    \n    x_ptr += ncols\n    y_ptr += ncols\n  }\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/lib/fft-matrix.js\n ** module id = 27\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nvar bits = require(\"bit-twiddle\")\nvar dup = require(\"dup\")\nif(!global.__TYPEDARRAY_POOL) {\n  global.__TYPEDARRAY_POOL = {\n      UINT8   : dup([32, 0])\n    , UINT16  : dup([32, 0])\n    , UINT32  : dup([32, 0])\n    , INT8    : dup([32, 0])\n    , INT16   : dup([32, 0])\n    , INT32   : dup([32, 0])\n    , FLOAT   : dup([32, 0])\n    , DOUBLE  : dup([32, 0])\n    , DATA    : dup([32, 0])\n  }\n}\nvar POOL = global.__TYPEDARRAY_POOL\nvar UINT8   = POOL.UINT8\n  , UINT16  = POOL.UINT16\n  , UINT32  = POOL.UINT32\n  , INT8    = POOL.INT8\n  , INT16   = POOL.INT16\n  , INT32   = POOL.INT32\n  , FLOAT   = POOL.FLOAT\n  , DOUBLE  = POOL.DOUBLE\n  , DATA    = POOL.DATA\n\nfunction free(array) {\n  if(array instanceof ArrayBuffer) {\n    var n = array.byteLength|0\n      , log_n = bits.log2(n)\n    if(n < 32) {\n      return\n    }\n    DATA[log_n].push(array)\n  } else {\n    var n = array.length|0\n      , log_n = bits.log2(n)\n    if(n < 32) {\n      return\n    }\n    if(array instanceof Uint8Array) {\n      UINT8[log_n].push(array)\n    } else if(array instanceof Uint16Array) {\n      UINT16[log_n].push(array)\n    } else if(array instanceof Uint32Array) {\n      UINT32[log_n].push(array)\n    } else if(array instanceof Int8Array) {\n      INT8[log_n].push(array)\n    } else if(array instanceof Int16Array) {\n      INT16[log_n].push(array)\n    } else if(array instanceof Int32Array) {\n      INT32[log_n].push(array)\n    } else if(array instanceof Float32Array) {\n      FLOAT[log_n].push(array)\n    } else if(array instanceof Float64Array) {\n      DOUBLE[log_n].push(array)\n    }\n  }\n}\nexports.free = free\n\nfunction malloc(n, dtype) {\n  n = Math.max(bits.nextPow2(n), 32)\n  var log_n = bits.log2(n)\n  if(dtype === undefined) {\n    var d = DATA[log_n]\n    if(d.length > 0) {\n      var r = d[d.length-1]\n      d.pop()\n      return r\n    }\n    return new ArrayBuffer(n)\n  } else {\n    switch(dtype) {\n      case \"uint8\":\n        var u8 = UINT8[log_n]\n        if(u8.length > 0) {\n          var r8 = u8[u8.length-1]\n          u8.pop()\n          return r8\n        }\n        return new Uint8Array(n)\n      break\n      \n      case \"uint16\":\n        var u16 = UINT16[log_n]\n        if(u16.length > 0) {\n          var r16 = u16[u16.length-1]\n          u16.pop()\n          return r16\n        }\n        return new Uint16Array(n)\n      break\n      \n      case \"uint32\":\n        var u32 = UINT32[log_n]\n        if(u32.length > 0) {\n          var r32 = u32[u32.length-1]\n          u32.pop()\n          return r32\n        }\n        return new Uint32Array(n)\n      break\n      \n      case \"int8\":\n        var i8 = INT8[log_n]\n        if(i8.length > 0) {\n          var s8 = i8[i8.length-1]\n          i8.pop()\n          return s8\n        }\n        return new Int8Array(n)\n      break\n      \n      case \"int16\":\n        var i16 = INT16[log_n]\n        if(i16.length > 0) {\n          var s16 = i16[i16.length-1]\n          i16.pop()\n          return s16\n        }\n        return new Int16Array(n)\n      break\n      \n      case \"int32\":\n        var i32 = INT32[log_n]\n        if(i32.length > 0) {\n          var s32 = i32[i32.length-1]\n          i32.pop()\n          return s32\n        }\n        return new Int32Array(n)\n      break\n      \n      case \"float\":\n      case \"float32\":\n        var f = FLOAT[log_n]\n        if(f.length > 0) {\n          var q = f[f.length-1]\n          f.pop()\n          return q\n        }\n        return new Float32Array(n)\n      break\n      \n      case \"double\":\n      case \"float64\":\n        var dd = DOUBLE[log_n]\n        if(dd.length > 0) {\n          var p = dd[dd.length-1]\n          dd.pop()\n          return p\n        }\n        return new Float64Array(n)\n      break\n      \n      default:\n        return null\n    }\n  }\n  return null\n}\nexports.malloc = malloc\n\n\nfunction clearCache() {\n  for(var i=0; i<32; ++i) {\n    UINT8[i].length = 0\n    UINT16[i].length = 0\n    UINT32[i].length = 0\n    INT8[i].length = 0\n    INT16[i].length = 0\n    INT32[i].length = 0\n    FLOAT[i].length = 0\n    DOUBLE[i].length = 0\n    DATA[i].length = 0\n  }\n}\nexports.clearCache = clearCache\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/typedarray-pool/pool.js\n ** module id = 28\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nfunction dupe_array(count, value, i) {\n  var c = count[i]|0\n  if(c <= 0) {\n    return []\n  }\n  var result = new Array(c), j\n  if(i === count.length-1) {\n    for(j=0; j<c; ++j) {\n      result[j] = value\n    }\n  } else {\n    for(j=0; j<c; ++j) {\n      result[j] = dupe_array(count, value, i+1)\n    }\n  }\n  return result\n}\n\nfunction dupe_number(count, value) {\n  var result, i\n  result = new Array(count)\n  for(i=0; i<count; ++i) {\n    result[i] = value\n  }\n  return result\n}\n\nfunction dupe(count, value) {\n  if(typeof value === \"undefined\") {\n    value = 0\n  }\n  switch(typeof count) {\n    case \"number\":\n      if(count > 0) {\n        return dupe_number(count|0, value)\n      }\n    break\n    case \"object\":\n      if(typeof (count.length) === \"number\") {\n        return dupe_array(count, value, 0)\n      }\n    break\n  }\n  return []\n}\n\nmodule.exports = dupe\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pitch-shift/~/detect-pitch/~/ndarray-fft/~/typedarray-pool/~/dup/dup.js\n ** module id = 29\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n'use strict'\n\nvar bits = require('bit-twiddle')\nvar dup = require('dup')\n\n//Legacy pool support\nif(!global.__TYPEDARRAY_POOL) {\n  global.__TYPEDARRAY_POOL = {\n      UINT8   : dup([32, 0])\n    , UINT16  : dup([32, 0])\n    , UINT32  : dup([32, 0])\n    , INT8    : dup([32, 0])\n    , INT16   : dup([32, 0])\n    , INT32   : dup([32, 0])\n    , FLOAT   : dup([32, 0])\n    , DOUBLE  : dup([32, 0])\n    , DATA    : dup([32, 0])\n    , UINT8C  : dup([32, 0])\n    , BUFFER  : dup([32, 0])\n  }\n}\n\nvar hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'\nvar POOL = global.__TYPEDARRAY_POOL\n\n//Upgrade pool\nif(!POOL.UINT8C) {\n  POOL.UINT8C = dup([32, 0])\n}\nif(!POOL.BUFFER) {\n  POOL.BUFFER = dup([32, 0])\n}\n\n//New technique: Only allocate from ArrayBufferView and Buffer\nvar DATA    = POOL.DATA\n  , BUFFER  = POOL.BUFFER\n\nexports.free = function free(array) {\n  if(Buffer.isBuffer(array)) {\n    BUFFER[bits.log2(array.length)].push(array)\n  } else {\n    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {\n      array = array.buffer\n    }\n    if(!array) {\n      return\n    }\n    var n = array.length || array.byteLength\n    var log_n = bits.log2(n)|0\n    DATA[log_n].push(array)\n  }\n}\n\nfunction freeArrayBuffer(buffer) {\n  if(!buffer) {\n    return\n  }\n  var n = buffer.length || buffer.byteLength\n  var log_n = bits.log2(n)\n  DATA[log_n].push(buffer)\n}\n\nfunction freeTypedArray(array) {\n  freeArrayBuffer(array.buffer)\n}\n\nexports.freeUint8 =\nexports.freeUint16 =\nexports.freeUint32 =\nexports.freeInt8 =\nexports.freeInt16 =\nexports.freeInt32 =\nexports.freeFloat32 = \nexports.freeFloat =\nexports.freeFloat64 = \nexports.freeDouble = \nexports.freeUint8Clamped = \nexports.freeDataView = freeTypedArray\n\nexports.freeArrayBuffer = freeArrayBuffer\n\nexports.freeBuffer = function freeBuffer(array) {\n  BUFFER[bits.log2(array.length)].push(array)\n}\n\nexports.malloc = function malloc(n, dtype) {\n  if(dtype === undefined || dtype === 'arraybuffer') {\n    return mallocArrayBuffer(n)\n  } else {\n    switch(dtype) {\n      case 'uint8':\n        return mallocUint8(n)\n      case 'uint16':\n        return mallocUint16(n)\n      case 'uint32':\n        return mallocUint32(n)\n      case 'int8':\n        return mallocInt8(n)\n      case 'int16':\n        return mallocInt16(n)\n      case 'int32':\n        return mallocInt32(n)\n      case 'float':\n      case 'float32':\n        return mallocFloat(n)\n      case 'double':\n      case 'float64':\n        return mallocDouble(n)\n      case 'uint8_clamped':\n        return mallocUint8Clamped(n)\n      case 'buffer':\n        return mallocBuffer(n)\n      case 'data':\n      case 'dataview':\n        return mallocDataView(n)\n\n      default:\n        return null\n    }\n  }\n  return null\n}\n\nfunction mallocArrayBuffer(n) {\n  var n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var d = DATA[log_n]\n  if(d.length > 0) {\n    return d.pop()\n  }\n  return new ArrayBuffer(n)\n}\nexports.mallocArrayBuffer = mallocArrayBuffer\n\nfunction mallocUint8(n) {\n  return new Uint8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocUint8 = mallocUint8\n\nfunction mallocUint16(n) {\n  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocUint16 = mallocUint16\n\nfunction mallocUint32(n) {\n  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocUint32 = mallocUint32\n\nfunction mallocInt8(n) {\n  return new Int8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocInt8 = mallocInt8\n\nfunction mallocInt16(n) {\n  return new Int16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocInt16 = mallocInt16\n\nfunction mallocInt32(n) {\n  return new Int32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocInt32 = mallocInt32\n\nfunction mallocFloat(n) {\n  return new Float32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocFloat32 = exports.mallocFloat = mallocFloat\n\nfunction mallocDouble(n) {\n  return new Float64Array(mallocArrayBuffer(8*n), 0, n)\n}\nexports.mallocFloat64 = exports.mallocDouble = mallocDouble\n\nfunction mallocUint8Clamped(n) {\n  if(hasUint8C) {\n    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)\n  } else {\n    return mallocUint8(n)\n  }\n}\nexports.mallocUint8Clamped = mallocUint8Clamped\n\nfunction mallocDataView(n) {\n  return new DataView(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocDataView = mallocDataView\n\nfunction mallocBuffer(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = BUFFER[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Buffer(n)\n}\nexports.mallocBuffer = mallocBuffer\n\nexports.clearCache = function clearCache() {\n  for(var i=0; i<32; ++i) {\n    POOL.UINT8[i].length = 0\n    POOL.UINT16[i].length = 0\n    POOL.UINT32[i].length = 0\n    POOL.INT8[i].length = 0\n    POOL.INT16[i].length = 0\n    POOL.INT32[i].length = 0\n    POOL.FLOAT[i].length = 0\n    POOL.DOUBLE[i].length = 0\n    POOL.UINT8C[i].length = 0\n    DATA[i].length = 0\n    BUFFER[i].length = 0\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typedarray-pool/pool.js\n ** module id = 30\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/index.js\n ** module id = 31\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js\n ** module id = 32\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/~/ieee754/index.js\n ** module id = 33\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/buffer/~/isarray/index.js\n ** module id = 34\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typedarray-pool/~/bit-twiddle/twiddle.js\n ** module id = 35\n ** module chunks = 0\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n\"use strict\"\n\nfunction dupe_array(count, value, i) {\n  var c = count[i]|0\n  if(c <= 0) {\n    return []\n  }\n  var result = new Array(c), j\n  if(i === count.length-1) {\n    for(j=0; j<c; ++j) {\n      result[j] = value\n    }\n  } else {\n    for(j=0; j<c; ++j) {\n      result[j] = dupe_array(count, value, i+1)\n    }\n  }\n  return result\n}\n\nfunction dupe_number(count, value) {\n  var result, i\n  result = new Array(count)\n  for(i=0; i<count; ++i) {\n    result[i] = value\n  }\n  return result\n}\n\nfunction dupe(count, value) {\n  if(typeof value === \"undefined\") {\n    value = 0\n  }\n  switch(typeof count) {\n    case \"number\":\n      if(count > 0) {\n        return dupe_number(count|0, value)\n      }\n    break\n    case \"object\":\n      if(typeof (count.length) === \"number\") {\n        return dupe_array(count, value, 0)\n      }\n    break\n  }\n  return []\n}\n\nmodule.exports = dupe\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typedarray-pool/~/dup/dup.js\n ** module id = 36\n ** module chunks = 0\n **/"],"sourceRoot":""}